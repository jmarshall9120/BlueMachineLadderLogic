// Options: Export entire program; Code Block delimiter instructions;
// Formatted Rung Comments; Element Documentation Database; System Configuration;
// Memory Configuration/Devices with Built-In Types and User Add-Ons;
// use Element names (no NickNames); rung/address annotations;
// <TAB> parameter delimiter; 
// Write/overwrite file C:\Users\jmarshall\source\BlueMachinePLC\BlueMachine_EXPORT_DMD.txt

PLC DM-SIM

// Do not modify SYS_CONFIG block!
#BEGIN SYS_CONFIG
cd04c3252eab3891e1d821d69c8b091e4ca6c877d7bc3b503394c20ec04069e2b4f6ae9aa16f5bdb
fbd7a703550949308fae0929e5fe8b45d552e18c7ebba446c9e2c03fe9113421b4607911f7ace52b
c789d142ae4172887affac5857971b3f79cf8bb4bb6524ddcda3b42bdeb53693112f4d59c84ce68f
5d6e56f520d8c0aa7cebac90c68af7ef0e5cd7059c7ed377321d40942e71e06d47eabf5bf9ab6735
4719c20df0dd80038b59fb355a7404c72bda590f8812e02d9070c611a0a51483b9405a0e7d46705e
732ca2614956f43d5945b496811400e50d828f352977e2a03924e5ea37168dd2367deddeca8664d9
3656a52493a9a010b303afac15462ff95ab9eb30f2d3d83d593749ca9852ddd08d8bd6b00877b234
781bf51feb60afc3a12ab5c6091d3480592ecbbc11d31e60309a092c2c56e2a16443c2e509bd26db
b8df6b3ddf47101e2a00839099f2b8a382a73877dac74765bd8a22984912db12c8a0065dcc0fda2a
dc3a8de88b12a6ce0ef84787c5f70b619bd24cd12c868d372b80ec7212fee88a1d95450b98990180
89de28a10c48daa75e884a4a23b1c6f5cef7ecb9399518bab28670d684c28eb6c31ce5f43318d0d5
c9a54cdd8bd3d2cf2ead328c57f1492cb13cdcffcd83c309ab48e10580276c188fe74f4dee3dcde8
8883267ade38914a554f886eeec93a8ca239828fe46bd9d736b854c0b5fac5725761655901676bf8
63de101c06b92af1af4073b7318a322851e429a63627065ab42a0029130836bd78afa74bf2d4f17d
f6cd7d3e74a085a0a40e01abdb2dece79dbecec8cd88f754cd24635467aecaecac1c63dc0e46bfb2
380c26ea0d81b6134ab1caf3f1eaa65baacee6584472b8e67bcfdf5a3fef76cd26c1725ca0dda97b
ec5373915b1d0f3a5302aebbb900d9cbdd2a763cc52449ca7d56b7b6da1f10822df2d10fbfe56070
46214fe902ed5551bf565c5347f2f3651ed03fb4138db6bfb58c0f1222cceecb7bbf2058f7607350
1d694c2664980ea7f7ab58c011867733c33511b89d0e46ad564870795751580d719aee7e517f8169
c02adaba99b48affc0afb2c1d6a20437f278c9af918a9f01d08e660eb31c5d5333bd2bc7ba89abb0
10818ad3d4953baf9ec4df42f30cd11e555d12fb4c2b772e75e7bc3641470e10618952cf66d53ef3
cee58e24c272583320732d4a0bd657d960c33c0c25c309bd020b21f511f66c59c9980c84f74c0b05
92b147c51aac1432073d24cb08ebdf86d113e1c38e92d8e2b5aac7441c43c47cd7ba85530ad5b0f1
a071200f06ad717175ba08d679504b37771483565ee591eebb17b9dfcd1ccaa384d9c2a19339b1b2
8b9a82e91d4d97a5a127b20265d6d32e9821762c4d1564c0f30f82c776df80a9b92e631fb8c2c7f8
aeda3ffe55fd7494d5ee87c29197dd815e37e0acc86d1571c1231e7d909e0783b30de30643d80703
e4bafc2d642c3ade4feada93440824d0dab2215b5c45106abf05090a739641ae33dca13c4716e180
e6956877f3f0473537a09bb6813162a8d0f8ce40353b69359e26314067b4f3b9574232e747abd27d
9be5b935dbeacff28eaea03b7a8ac1d4600101fe64a7b25796837cbd621b00ad119e30469f2272fb
ef38e5d8c6dfbb4de31d5156607be55b082da965f1bed11de9529248badfc910a693443c71484163
c3801c1bdc987d1a7f9a4a0681083e14d2d491242448071a2b1b3bae309dd155af1676f3eb2dd984
fa58ec61ef75bd30f8ed075f4ad3da2f451891a6039b818a54c947dd15d811846000aceb78df004b
c2f550882479d3c7a040e374c10b98c092734ed50fe8297621a1421e6fc7275ad8db5d139e0ddb39
1042aff305ae0ce68ee99b6e4f8b7cb5c071cbc610268c7b3b008280d77263f24e28be912d996aca
353e422d1ff1a21e793f1281bd53aa6fa63be0a625bfbf20846e454a2036c3c233f1b312ace4ed9a
45289f9449698f466dd52b683b68e7c21fefabd05f50c801e0a8b06c74bdceaa985a3a77aa9a86bf
8606936e557f2537fb06a774626bae25a3be0ca906ba2dbaf4997bafa751759d857bbeebc2a13296
097f84d8e7f4e43ce3685c4a9a69c3f6980d4acf8fdaf6f5586e08274ba1862d4a2ba0624a2bf0ba
770e959d94318748061b14c0e74c483e2a926dd2ce650908a0fdf451fbeea23185a2fec1f4aa173c
96019b20cdfb6ac35b9e45f4abbf10526459cd052fba029d90f78e3832efc3e23fc7bf65b5bd3f39
ea7b6457aa8ef41f930b0254c6ba9100ff5e080938a984209e810c1d8b1e1b2f699d5997c8c5d14b
e2d5f3672b286fba3b5284502a8cf6444eeaf6d0e7c0d7841e2b55efa8d1166443d7ea4bb0324de4
5155666305ca30cc4da106c5e2b517e652bfc20f58ac5d807dbf0855cc448008c0ad85062be5e23d
dd2b9addab11ed3e9292b86e1f8bce16a7ee1dc4505d4278e0c44cadc9637ecbc2e0f8a2ab69a031
3fd609be7576cd1a4cc6b5a2279735d85dd5dd55f52b348e565a36810acf4f473fbaa53b15d87499
16ad945d092e51e6fba63c84cbefefe98f509ce96a3298d3cfdfa2c48ad4f83956f3d5e8ecf33447
2ab4b11f9f0d531115a3a07744cfe710dbf45db8cafcf9948c30a31ac061670e3f58b5682eec6928
51ce65983ddb439bc108dbc383eefb20ed078dbee510b7f9fee0533f9df0277a5b5e0aa5227dc343
dbf4b488e0991a2aab8d368239a2e70ce1b991aa7778b73a5b09dcdf53248bd6a5dc0bee12780f08
9e79402095949ab5eb55364644516c9ce4889a0195d2ef0bd8fbab8e1fff5786bfd7159b6ce5f399
140dc73e1a07ed935c58c6aa3699c2279f1a4dd845c9243f1fb25ac22e3157db04480cf796b407e0
c9908c52693659aa20dc31ae7f6d778560f3c078905d8d5be8631cf16ccd8d66c9546b419f900d75
92465ec32cfd0862f4a6cae8b515153adc2c10410fe797bf82bd9b004e7a7808a39a6f17fb2b6e6d
9671b0b95dd750d7637eaa3d9f1db27c149cf22b50f6df6855f9b5d291705f6d1f3081862603a5f7
4228ec8bb4c6ab8069081b768de412fc5a3eda03832262c9942472702fa3a21e5180a9428ac4ceaa
3b9e5470abfb8950e1920a867d09dfb39e01b7787bb3056232502b0f0af5c3bde1753ea214a1c437
934df897319dad177f7f6e4447f8c02b4cab6227cbf405054c703ad5a03ac495bed1ebd722df05dc
61ad871abcc3510fb284285af047e87d7f33b947159b0f0f84d9693349f712264693d02633509060
aa80cab50f428b7ed66d86c948521860c83692a2d1e4f1e7a499e44a4fc9284fe5ae74d250eedc38
1984446ff488ecacf2e7b0ef220b521d734a805e69ebd432aafab89ef8f9d3d430db73db8414886e
9e781f9133d9b1d6268ac91dd2d5bf2d32cf6ebdab1aef40d167a08ff2aa607d7d7e5c47448ce593
22c911b7e0d6d3dcf4f40f35ab96716e17083df39ea2c668127fbacd7c5d4f0b5a051d9542b8c152
7ea619b1a86b2263336d1b5a8571f30a0e07e2db1c17e9fecf1664874592f4e944ef5990e7573c9c
bef2673809892635f546227ca8efef6d88b951c1b8a79dd9065ecc4435a21378d836ba4a6281f8c3
b1fe981a65a247a054a5aaf4a436b3c274f41502904fb3124918d84cb2885e5aef2f77e75ba39618
3071ae5a20d96dfeb147bd373fbd272232c1c0311b1fc6403f2e36c43be73bf42e426f70408ac351
6c13f22f51657642104f572ffacda1321e06ac30023462e9f7d94ced185bc9f27beba540e5f4a92d
0de467f16bc00573d11f9aebf2a9fdc9260a83001c357889fd5f7ec761ddd665bfda7ee218ae34b4
8e20a1de5b1a701511a70ca6d23c9f600cd1c45718ee701bd151cbce46347385afabc2442cb7f69c
79646a153f78a06108de4f321bb885eaac3a9a467f450c5e44dc171ff6e3d20b799d5fa5d865f960
4345252fa87bae79b4d9b677def8e07484004890d49ddad6a2f78406797e9f24c690a119401e302e
4db28a7a08613f15d4bbdc10a3896a13d8ab69b19a1f44ad7e94168c89f90aeb275ae7fb69225ca5
054df3a495f86b479f3098f464d82035bb7f2b60effe3bcb7de1810ef97e01b273cecddcbab33f3d
5bdf162dd030ec15994b22aede60708212d468142c14599dbce95cf16be08bf3c833a15e0da26004
d369caf0db9bb72611535206a38f74e5c6d5c5468442916baf3c9708ee9dcf358954db06cdd2c383
31f8268c6fe27812ef7203c4f9d8477045cbeda94e868eb61c5dbbaa5c0988fddf9e0a5908d7c36a
51979324343a4be8bb398f6bce22d595ef0a1e246d42459d22eb2c11d0bed91487d762b20c7b9a1f
01e4dc7b710ff199e5812f553c53258f41c8b9269596304740a87b891f8581718170ac8680199ffa
6edfea45adbba95394c1f75ec20070731f4728de1bb852b59edc19dc5c62cc4e85b2f15e4b340d67
c5355778b4a935020d3c579d9b200615abfcf215991d51d90f6d31e8488f3a4dfaf8feb527da9022
5b1f92e7cfc056974fe194b9f0649e596a8045822770f84febf232c5c92f8e352103503035643ad4
09977073f49b7c56973107dd5e115d15c1497c8d629435a6426fa2eb9b48f36a88d196e2b05ab192
9531fde1f1afee8a055e499171a21ad3f1d90b01aadfd0aa6fc08393da92e6d7835bbba88307e3cd
eb279e23e50df171790069cecaa85eca8045ec3431566eb7465ca68cfda9de82e319740d5223abc0
c3efd2874822b976c476365ffd5714d186b1d65dbf43f85f8992e62d75188d7101481370b57a6a3c
be58ce6acaaf9ecb79265d780aaf3852831cb72762c57b1460b941f68747900dac5fe59309650817
3f64195a3eca9b3d2e65af99060fd674d3bf395439e6cc97eae9a604459106ee8b69959a8d032d4c
5e423f993adaaa3d01b3abfa1d01b1588f129f6cd6a08e80e89a8737f88436c01156849370517cfb
b13ec934603c07a012a425be27d0d5d2b5494cbf33f88d7eec9a1bedb65841e775b6003424dd707e
66d29f4e2ec2f0c670eed96bca2023fa989b35a7be81860fabcf896f87d35caccfead54b8a0f74ee
3bd1a573764d2cd946b6bb971c6ca5900a5373303f4dc3edb88d00c45ced265a5ffd6d11574600c2
ce137134be14ec7b9f74cdded5cf39f0210ccf7db131a5f87fb387156b676f4472e821d42c630aba
702c4bd18eb948d65e23549b8aea0d8a66fbdac0f8d2d52b220dd229c1697ed594fbb2320ff19124
91e6bc17dafb6e702093eb5432a339cf510c09545a3899156fd4ef11379e73a8ea75a9162ccf51ff
e1c77ec36d3a926cf6a2c115e6cf92287dbc8c8927401521cc04b89a56488fe0f7554aca1eab45b6
f03b0f10d36cfbdf0eb0009a594a5dd951385ff55c900963e4dc12b6342d49821cae06ecfb47b021
25e3f80d044ce278b54ee98e0b8cc6dac3234dff72e4c0d394e8eb8cbb6c457020dc830ab89ff476
a31d19cb2b262264c36fb510ce5bf581a801f3ff3da7e8bb552a825c78592669ccaa088320235e87
37ea0126e35f960c0bd0e59b68b2846befda6aa29c772a2da1bc0b08a7d0d9f5215944fca28a2658
90ff305cc2334e78fe96376c2324105c941213afb3f4616eb68064b397ff8b792ef0d58b3a5f74ff
fa1ea5292684137fbb2cc767cc71c2639fbba1838a46e0d83ce0cea6382716c2274b83150f117668
e6116894ef4768d52c267f6aea6259842ece1ab1285c8b2fc7c05a5bd42f400d0a84322746a27bb5
c2106317721aa6c24eb59938539318803d3a9f6d64585d8440123e7cf00e2f759678f6fa3ec29591
63f0d4088c862f356b8834ace824a43e5733a95a687b66daa43c951909819c3ad5e511c4eb90a634
07bdc2f022d512daf101357455691fa6d5a5ddba1cf4928fae739bfcd71a82200b5031591ca552e1
efffcdc31663bd62ec5eada4d819ee9da8d2a8425a78728b070143840781145f7cadf0e5fa4a2c91
5149c5612ba3b7a64181936570f9b677bc327b81302e32b4ee170c97fa9d880daddd5630032e0fe8
ae35a5d034a1e2e01baaf307e498151affcb78732ea10d9263e28a7b90ac490bfc2a50849d75b308
9ba72400d5415ee409a19a721efc8b5a26149180a047551a292e78886893a5c814cb272543a8b3ba
99b360dc1c889197d0e5b6e9018bd95ad18cd995ee72401a25dbc48734cc6c880dc7fb43b36f86fe
9d11dcd4b6f7e2ade167e091553af63304e625b203fc4d972477550912712d74714e839aedeb8290
5d4eed20a12c0fa895bed47ef877e13cdfecc217037c51c7f1db7a3eefd5226699c38e7ec2b19955
061249a12cd0d1e8344f844b5b888327bb0163f40aca813242b0d1e7cbff64cf97cbf1a12d34cbb1
75c1eda2baf865c911f3dbb0926fe390d49275f6659cb8614f6a6db46d125073b6f09e887cf69e41
68cdaa68606e87e6152ef0d19bb132ece1cc7a80b41c928b6f32e748ea9f5fa2d268bf9596047786
46f7f45896a1ea4a283fc202ef2f2cd33e036d7f2bd3fbb6d7689bcb2b9fc4376bfb3cb35a957106
93498a0c1449fb467fb550ab2d1d488df52b8dc7e65c49db7ccb7bc1ac2a52f063fdf60730aae2d9
222bbdad0f3edc63d1bfd955252ba298dcf3a97a72d6c40c7ecc0d96722405648d1fce95e277ba2a
63ed6f04824015714e3f4af7fc063232608133d03be47dc42d4a981f892c0a488f3383437c6f670c
a3bc007d2a051a1a86190e978200369ef3ae25ad94ccb717e89ed781d01349bc5b4cf4658ed3638c
fc3d23d541775d46a597e8dc39add1592529852355b0a7a9652857b66552fabe998db8e81b978acb
509b060a26ba257ee6f37157ff21bed5df257d06c231106ce524db59c6981d4d035787f396754412
639a9851ebea7b549042d7b113a0fed2ec78d5235e3417e72c0d4544f183642670e57d1821c040cb
4e6932f38d70c0370a6e46d7d0d98cb3ec2def6ee3922bcd9ccc5c37f0b9e85d6815ff49df817373
d16c8716944b32c7054d2e5730a58e433a9297efe5f798f0e1ca0a8292746c0af862a46f916c7670
6245c6dfe3b7a739d6a60855b207ecdf7a1bb476a5aa9845f512b173d50dcd036e8176c2bded8395
07ba698483e4f1060f1fd2152923dde6ff7e6f805658fd6ffac8290620e9ba205adf452769eba526
495d27792e6ef8f459c0882e5ba68a902989fe09029ea4e7e2ab4c2eb8211d1811f69654e935a64d
ef676271bc280b708b3725f54523f2c422f7d51d041f696dd75a1b217dc9f4d252a906cb18901675
72b1d8bf1613144487840e55dee2fc3d91268550f982ee00a355e8cb29f4574a191e16e7843a929a
74a0b6d87c81bae8be8a65bb9ab3e22e1efa022571bcf1b3fb3b3bd0eb943359852e2bfe6a90df64
89827c4b8429a814790118e0cc91f2adad18bb2a93aefe976451a393ef5dece56c708dc3af388275
78d311ad047a79e4287ffd618d5bfa58b610957d0ba84e3fcfbaef1e71c21857f335e41a4707a9cb
25676c5ed033cafc045a741c1572dc3d53c770c665192fc1cf5b587534e1320c1ef74a5f824bff35
478f6483acc066cd7457d4a17a615b49bc714f8f5adfe533f41dd24f5b60aea5ab3f523ac4a400e4
54348425d614450be0eab5aaedf26a5910ef1ade990840c1d93eefe919deec5dd688bfa64168cabc
904906cf3000e5e23fffe2a85993d470627a6b52e42b5527a678844c0a1f067336c3f1b478d67e65
f5268dc548dfd4844cf725ee6b62a39375e82eb8bbf34afe4023e22eefccdb574bee9d06c682a700
fc7ca1c8b12646f22da107ceb7442f1318aed7882a6fa5f6efc197d96ec9d701ab89b081c91495ab
8d14980aebfa280b83e35962a21982acaa0c5ca68e8e7e6e11a4a7781e2e0a82f0876e72030faf2b
08fb02aff9bd99e2cffa80722e9ec1e860de06817640dabe9e1c8e59ec07cb43aa05b86c6fc61578
549cb269cb9c340ab80c3e836c8cc7603ae8003bcd430c324336ef029528dfe0175776e6ac0758fd
e0aff6504efc5e39a4b2139f4200d7cfa4ef75a57c642c881577b21e841d413c23543ded9f930460
7fc485562e3013fc035768f555ebbf8bb81e833c5bc50a0abadd982623842f0c1297a2ed28eadfe1
8907079c895d2f7742caf6469b84a544b2cceebb317466f4b8d1296fe6195a6fc37dae53d3151e55
6ab9fba3d93ec0b5e808ee870e4d2c761f43ea5ce1772d887449b5003c76bcdbcff6d184ad22e382
d3d8a16aa62b649d2287535cb6136029472631124aadb801797530c69d482e358403dd3e97647b0f
edb6151cee975bd49d0fe27c6349dbc2d49d0c46b34dabcfe80ea2999100ae6a5eb9fa70aa17b9d1
6bcfce0078af09fb8f7505b285ae70bc12bfaca41552a4ea10e625f40fc6cbf01038db62c94e62e7
abce8d3eaf19c8db98e78d76d3c1d7ced16013d9d6f977528eaf90e306c20a5490d21ab0e32e9c32
db1628bbf77e550295fe1e35092bb02ff3020332cd344199888aacf89128a321f759839c239b2f65
74e0639f6e47d9196d2ec03382ae57680328eb011adb3cab89a7df8ed51fde4ef8f541cf94b969b6
946253c6c19bdb9b3121428265c97aaf28fb4b5fe1f5d14124cb56c13bfb65999674fbfdd5a7950d
7ecbe8341d65a875b2241818cb564caf4480570b34c11344946631d1308d584f672764acb03e2260
df9e90428893948b67a9b3061355d634b0e769a27ecd9c9284d66a4d3128082f3d10a840db1b295d
f3b05b1faa4eb7d8fe759057e8629516c70c8ddc89d1e125b94caf6f997c356ff06d76d4d39e15e9
18166a3c566e8afdf8030b0067a943a0fbfe230b56769fa5fdac4a58d77eaf2a314d2b5fdcb48ba4
084c1294b4097e79868ccb25e7d3392ded63df29d0231ff3d74f12d0e3fff66bc76a2c7391a49068
da3a79f0c7d0b1a210a23818ac44ab52f89a13f0532de9aea1a57df419f332f5551d5620c9c6737a
99318c3206309e6783ae1fbd0410cb9b07537b6a2d4382590fb33f4f49f3b94272f6dbbb52e8f35e
2a83c7625d1533db0683c29456c4578182104e7512b18af02d6d02378177ff838a291f2899438e48
cb732996075f2831f762b2f51841530c07ed49a18cb98c32bc16d1e2a76eda834b05a95d13e77116
1b5800f8db65307ebf9f1a370ef77a8fe041ca1a1a3e6ecd4da5aa5b7ea06bba48dbe53cc92247f4
78b40977a6d7b910c3341a9d27a316efc45b7bfb12311aceb77856611ec54e5260189adf0c147e2b
92c00d70ed380afecbe25051577adbadb792b2893c1b49755ddd515221e697bfc6af122c83781b5c
e8e40de1d1e2f32c72924d03f3dd68c681dc78e47196d0f4f3da7f5d10d69c1594d81288e9cd7a72
b10302cf6b78111139afe4280ec74ba2f83f5a0c05e0b44125f9536e01545d3b1b6781c70460808c
ba54d2fa4e151c02dd92635ca54cb9884712802d94dda4f48725f2e2753d5da5378b2e046073a345
0e7bc1c89d15346ce6f6c80d6b4bc54768614210b395593cf150b0166735ecf1d8c67a19e2eca6ba
9a1ff99f7a1e8765efbc3366c04cf5a88f731416f1b4c954fdd96bca7dc497ca8db009a1a51a76a7
22a2c16c0916d22b77757bfa8650768d13cd6c9bf7840808316de308c30317d7cd3343f706f5abc7
27c894f93c749022e60c2f7712053f83468e34fa541f4aeb93ca71952534c59be2033c68f3e083c3
45a092c2e59d5a4b8635c2d584e3c613dfcff55b022b42e3c06dd3a06735c6825030a1b3280528f5
3acdcbfd274583374850a19cad1a9ae28ca48fb99a6eae3ba8bd3e33c46f019f000b7c57336a7124
4af070858ca81bbd400279850cc52b36fd2ca8c1d47eb53e2b4a17da9d26584c322d83a1558ce919
22ae555f32c6a63fc284d18db6d6b86dbc344d17a023d7b8419b1ae54214d26734c4b2b6e93adea3
50fc97616189fefebce4c103239d88eb996da0e75abbc4e295aaf82346b552080dfcd47aff1062de
bea0ad290ee13ec7ba420c586b3a3f72c0bb4b9c9eb5c227c6c1556c59662f111d259be505111551
0438f69a4f2ffbf77c46aa635288f4255c132f79510337c16f05290736b1aaa37e775cc773a462db
5fea900486b60cb5c635ecd648227028240e64b279c246a33b9abfc5f0c8f5a2306fd0ae6b94e9c3
afd731d762c302be350f5e6731fb9dd7f85efe8879b5d2004d82a56429a4ac302042ce9157a82c85
3a21b19bf791beb8ce05df1db3028b1730560739a1ecd1071b7f15880e1395f73c973d7d14d2e151
9b3565cfddf9204269f6e43cf52e0f2d9064ffb05758eeacb9c62438ad342b5b9b585c9439d2c540
f951b23c03e9dd7a75b0adfe9605912ce5644ce641d0e8cb7fea3524958e548dce6c6deae0276475
10dfc0f80cba1c2b4336f5953cee695dc1db790ae68296053cc4d15100cb64f15876cd14ec1995cc
4bff319f16aa33054f82a90631e8625be806fb07468e0663918b31d0
#END

#BEGIN DEVICE
	@LocalIOMaster, 12, 27
	@RamFS, 1, 1
	@UserLog, 7, 11
	@IntEthernet, 4, 2
	@DMLogger, 5, 10
	@IntModTCPClient, 9, 14, 1000, 2, 60
	@IntEIPClient, 22, 31, 1000, 2, 60
	@IntEthDMPPClient, 23, 32, 50, 250, 2
	@IntSerial, 10, 15
	@IntProcSim, 11, 26
	@SDCardFS, 25, 1
#END

#BEGIN MEM_CONFIG
	X	BIT	decimal	2048	-1
	Y	BIT	decimal	2048	-1
	WX	SWORD	decimal	256	-1
	WY	SWORD	decimal	256	-1
	C	BIT	decimal	2048
	V	UWORD	decimal	4096
	N	SWORD	decimal	4096
	D	SDWORD	decimal	4096
	R	REAL	decimal	4096
	T	TIMER	decimal	256
	CT	COUNTER	decimal	256
	SS	STRING	decimal	128
	SL	STRING	decimal	64
	UDT	DATETIME	decimal	32
	PL	UWORD	decimal	256
	DLX	BIT	octal	01000	-1
	DLY	BIT	octal	01000	-1
	DLC	BIT	octal	01000
	DLV	UWORD	octal	04000
	MI	BIT	decimal	1024
	MC	BIT	decimal	1024
	MIR	SWORD	decimal	2048
	MHR	SWORD	decimal	2048
	RX	REAL	decimal	256	-1
	RY	REAL	decimal	256	-1
	STKC	BIT	decimal	256
	STKD	SWORD	decimal	64
	STKT	TIMER	decimal	64
	MSG	STRING		0
	ERR	STRING		0
	SysName	STRING		0
	SysDesc	STRING		0
	SerialNum	STRING		0
	PartNum	STRING		0
	NewStker	PROGRAM		0	-1
	TestNewStker	PROGRAM		0	-1
	Stkr_SetState	<Virtual>		0
	Stkr_DetectState	<Virtual>		0
	stkr_CycleState	TASK		0	-1
	tst_mock_stkr	<Virtual>		0
	mock_stkrStart	TASK		0	-1
	Stkr_BufferX	TASK		0	-1
	mock_stkrCycle	TASK		0	-1
	stkr_BufferY	TASK		0	-1
	Run	PROGRAM		0	-1
	Glue	PROGRAM		0	-1
	tst_stkBufferY	TASK		0	-1
#END

// Beginning of Code Block Stkr_SetState
$LGCMOD	Stkr_SetState

// Rung Stkr_SetState#1
// Offset 0
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set Stacker States<br>"
"#########################################<br> <br>Set Rest "
"State"
#END

STRE	STKD43	0
SET	STKC10
RST	STKC11
RST	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#2
// Offset 9
#BEGIN FMT_COMMENT 
"Set Ejection State"
#END

STRE	STKD43	1
RST	STKC10
SET	STKC11
SET	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#3
// Offset 18
#BEGIN FMT_COMMENT 
"Set Compression State"
#END

STRE	STKD43	2
RST	STKC10
SET	STKC11
SET	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#4
// Offset 27
#BEGIN FMT_COMMENT 
"Set Transfer State"
#END

STRE	STKD43	3
RST	STKC10
RST	STKC11
SET	STKC12
SET	STKC13
RST	STKC14

// Rung Stkr_SetState#5
// Offset 36
#BEGIN FMT_COMMENT 
"Set Load State"
#END

STRE	STKD43	4
SET	STKC10
RST	STKC11
RST	STKC12
SET	STKC13
SET	STKC14

// Rung Stkr_SetState#6
// Offset 45
NOP

// Rung Stkr_SetState#7
// Offset 46
NOP

// Rung Stkr_SetState#8
// Offset 47
RET

// End of Code Block Stkr_SetState
$LGCEND	Stkr_SetState

// Beginning of Code Block Stkr_DetectState
$LGCMOD	Stkr_DetectState

// Rung Stkr_DetectState#1
// Offset 0
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Operational States #######################<br>"
"#########################################<br> <br>Detect "
"States<br>#########################################<br> <br>"
"Trasition State"
#END

STR	ST1
MATH	STKD42	"-1"

// Rung Stkr_DetectState#2
// Offset 8
#BEGIN FMT_COMMENT 
" Reset State"
#END

STR	X18
ANDN	X19
AND	X21
AND	X20
AND	X25
AND	X27
MATH	STKD42	"0"

// Rung Stkr_DetectState#3
// Offset 20
#BEGIN FMT_COMMENT 
"Ejection / Compression State"
#END

STRN	STKC0
AND	STKC1
AND	STKC2
AND	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"1"

// Rung Stkr_DetectState#4
// Offset 32
#BEGIN FMT_COMMENT 
"Transfer State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"2"

// Rung Stkr_DetectState#5
// Offset 44
#BEGIN FMT_COMMENT 
"Load State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
ANDN	STKC4
ANDN	STKC5
MATH	STKD42	"3"

// Rung Stkr_DetectState#6
// Offset 56
NOP

// Rung Stkr_DetectState#7
// Offset 57
NOP

// Rung Stkr_DetectState#8
// Offset 58
NOP

// Rung Stkr_DetectState#9
// Offset 59
RET

// End of Code Block Stkr_DetectState
$LGCEND	Stkr_DetectState

// Beginning of Code Block tst_mock_stkr
$LGCMOD	tst_mock_stkr

// Rung tst_mock_stkr#1
// Offset 0
#BEGIN FMT_COMMENT 
"##################################################<br>"
"##  MOCKS  #######################################<br>"
"##################################################<br> "
"<br>Mock Stacker Operation Reset State"
#END

STRE	D50	0
SET	X18
RST	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#2
// Offset 10
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Ejection"
#END

STRE	D50	1
RST	X18
SET	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#3
// Offset 20
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Compression State"
#END

STRE	D50	2
RST	X18
SET	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#4
// Offset 30
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Transfer State"
#END

STRE	D50	3
SET	X18
RST	X19
RST	X21
RST	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#5
// Offset 40
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Load State"
#END

STRE	D50	4
SET	X18
RST	X19
RST	X21
RST	X20
RST	X25
RST	X27

// Rung tst_mock_stkr#6
// Offset 50
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Broken State"
#END

STRE	D50	5
SET	X18
SET	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#7
// Offset 60
NOP

// Rung tst_mock_stkr#8
// Offset 61
RET

// End of Code Block tst_mock_stkr
$LGCEND	tst_mock_stkr

// Beginning of Code Block $Main
$PRGRM	$Main

// Rung $Main#1
// Offset 0
#BEGIN FMT_COMMENT 
"Begin Buffering Air Cylinder Outputs"
#END

STR	ST1
ENTASK	stkr_BufferY	0x0	0	0x1

// Rung $Main#2
// Offset 5
#BEGIN FMT_COMMENT 
"Begin Buffering Eye inputs"
#END

STR	ST1
ENTASK	Stkr_BufferX	0x0	0	0x1

// Rung $Main#3
// Offset 10
STR	C200
DUPBOOL
ANDPDPF
RUN	NewStker
POPBOOL
NOT
HALT	NewStker
OUT	C700

// Rung $Main#4
// Offset 19
STR	C201
DUPBOOL
ANDPDPF
RUN	Glue
POPBOOL
NOT
HALT	Glue

// Rung $Main#5
// Offset 27
STR	C203
DUPBOOL
ANDPDPF
RUN	TestNewStker
POPBOOL
NOT
HALT	TestNewStker

// Rung $Main#6
// Offset 35
STR	C204
ENTASK	tst_stkBufferY	0x0	0	0x1
NOT
HALT	tst_stkBufferY

// End of Code Block $Main
$PGMEND	$Main

// Beginning of Code Block Stkr_BufferX
$TSK	Stkr_BufferX

// Rung Stkr_BufferX#1
// Offset 0
STR	X18
ONDTMR	STKT0	STKD0	STKC0

// Rung Stkr_BufferX#2
// Offset 4
STR	X19
ONDTMR	STKT1	STKD1	STKC1

// Rung Stkr_BufferX#3
// Offset 8
STR	X21
ONDTMR	STKT2	STKD2	STKC2

// Rung Stkr_BufferX#4
// Offset 12
STR	X20
ONDTMR	STKT3	STKD3	STKC3

// Rung Stkr_BufferX#5
// Offset 16
STR	X25
ONDTMR	STKT4	STKD4	STKC4

// Rung Stkr_BufferX#6
// Offset 20
STR	X27
ONDTMR	STKT5	STKD5	STKC5

// End of Code Block Stkr_BufferX
$TSKEND	Stkr_BufferX

// Beginning of Code Block NewStker
$PRGRM	NewStker

// Rung NewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"#########################################<br>"
"##  RUN STATES  ##########################<br>#########################################"
#END

NOP

// Rung NewStker#2
// Offset 1
#BEGIN FMT_COMMENT 
"Begin Buffering Air Cylinder Outputs"
#END

STR	ST1
ENTASK	stkr_BufferY	0x0	0	0x1

// Rung NewStker#3
// Offset 6
#BEGIN FMT_COMMENT 
"Begin Buffering Eye inputs"
#END

STR	ST1
ENTASK	Stkr_BufferX	0x0	0	0x1

// Rung NewStker#4
// Offset 11
#BEGIN FMT_COMMENT 
"Shut Off Grace Period<br> "
#END

STR	X16
ONDTMR	T17	6000	STKC42

// Rung NewStker#5
// Offset 15
STR	X8
TIMEDOUT	500	STKC30	0x1

// Rung NewStker#6
// Offset 20
#BEGIN FMT_COMMENT 
"Machine Pre-Run Error"
#END

STRN	X32
ORN	X1
ORN	X2
STR	Y0
ANDN	STKC30
ORSTR
OUT	STKC120
OUT	Y0

// Rung NewStker#7
// Offset 28
#BEGIN FMT_COMMENT 
"Machine Runtime Error"
#END

STR	STKC122
OR	STKC123
OUT	STKC121
OUT	Y2

// Rung NewStker#8
// Offset 32
STR	STKC30
ANDE	STKD42	0
RST	STKC122
RST	STKC123

// Rung NewStker#9
// Offset 39
#BEGIN FMT_COMMENT 
"Pre-Run Setup"
#END

STRN	STKC120
ANDN	STKC121
OUT	Y4

// Rung NewStker#10
// Offset 42
#BEGIN FMT_COMMENT 
"Machine On State"
#END

STRN	STKC120
ANDN	STKC121
AND	X16
ANDN	STKC30
STR	STKC100
ORE	STKD42	0
ANDSTR
OUT	STKC100
OUT	Y17

// Rung NewStker#11
// Offset 54
#BEGIN FMT_COMMENT 
"Machine Stopped State"
#END

STRN	STKC120
ANDN	STKC121
ANDN	X16
ANDN	STKC30
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"

// Rung NewStker#12
// Offset 67
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set States<br>#########################################<br>"
" <br>Detect State"
#END

STR	ST1
CALL	Stkr_DetectState	0x1	DST511	"3"	"3"

// Rung NewStker#13
// Offset 75
STR	STKC100
ANDN	STKC31
ENTASK	stkr_CycleState	0x0	0	0x1

// Rung NewStker#14
// Offset 81
STRN	STKC100
STR	STKC31
ANDNE	STKD42	0
ORSTR
HALT	stkr_CycleState

// End of Code Block NewStker
$PGMEND	NewStker

// Beginning of Code Block stkr_CycleState
$TSK	stkr_CycleState

// Rung stkr_CycleState#1
// Offset 0
#BEGIN FMT_COMMENT 
"Reset variables for first cycle"
#END

STRPD	ST1
RST	STKC40
RST	STKC41
MATH	STKD45	"0"
MATH	STKD40	"0"
MATH	STKD41	"0"
MATH	D2	"0"
MATH	STKD43	"0"

// Rung stkr_CycleState#2
// Offset 34
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Transition States #########################<br>"
"#########################################<br> <br>Cycle "
"States<br>#########################################<br> <br>"
" <br>    1. Set a bit for every latch cam cycle.  If this "
"bit is not <br>        reset by the end of the scan it "
"means the cam<br>"
"        cam cycle was missed (our cycle is taking too long)"
#END

STRPD	X17
SET	STKC43

// Rung stkr_CycleState#3
// Offset 37
STRGT	STKD42	0
MATH	D100	"STKD42"

// Rung stkr_CycleState#4
// Offset 47
#BEGIN FMT_COMMENT 
"    2. Determine if stacker should transition state.<br>"
"        * If stacker is in Reset State only cycle if<br>"
"           the latch cam is detected.<br>"
"        * If the cycle is not between state and not "
"<br>           in the reset state.<br>"
"        * aditionally the timers must not have started "
"<br>           yet (its the first scan), or the lockout "
"timer <br>           for the current Cycle State must be "
"expired."
#END

STRGT	STKD42	0
STRE	STKD42	0
AND	X17
ORSTR
STR	STKT40.Done
ORN	STKC40
ANDSTR
SET	STKC41
SET	STKC40

// Rung stkr_CycleState#5
// Offset 62
#BEGIN FMT_COMMENT 
"    3.  Get variables for state transition<br>"
"        * Each Cycle State as three variables associated "
"<br>           with it:<br>"
"            - Stacker Operation Next Cycle State:<br>"
"                    the next state to cycle to.<br>"
"            - Stacker Operation Lockout ms<br>"
"                    time after transition before a "
"transition <br>"
"                    can be considered again.  Minimum "
"<br>                    transition time.<br>"
"            - Stacker Operation Timout ms<br>"
"                    time after transition before an error "
"is<br>                    thrown.  Maximum transition "
"time.<br>         * Note: Transitioning from Reset State to "
"Ejection State<br>"
"            must reset the Latch Cam Open bit or it is "
"assumed<br>            we missed the cycle and a Missed "
"Latch Cam Cycle <br>            error will be thrown at the "
"end.<br>         * Note: There is no way to detect the "
"trasition between            <br>            Ejection State "
"and Compression State, so we must <br>            also test "
"those states agains the Stacker Operation <br>            "
"State Set to determine the expected state."
#END

STR	STKC41
DUPBOOL
ANDE	STKD45	0
ANDE	STKD42	0
MATH	STKD45	"2"
MATH	STKD40	"1500"
MATH	STKD41	"2000"
RST	STKC43
POPBOOL
DUPBOOL
ANDE	STKD45	1
ANDE	STKD42	-1
ANDE	STKD43	1
AND	ST2
MATH	STKD45	"2"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
DUPBOOL
ANDE	STKD45	2
ANDE	STKD42	1
ANDE	STKD43	2
MATH	STKD45	"3"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
DUPBOOL
ANDE	STKD45	3
ANDE	STKD42	2
MATH	STKD45	"4"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
ANDE	STKD45	4
ANDE	STKD42	3
MATH	STKD45	"0"
MATH	STKD40	"1000"
MATH	STKD41	"5000"

// Rung stkr_CycleState#6
// Offset 211
#BEGIN FMT_COMMENT 
"    4. Set the new Cycle State"
#END

STRNE	STKD43	STKD45
CALL	Stkr_SetState	0x1	DST511	"3 STKD45 STKD43 1"	"3"
RST	STKC41

// Rung stkr_CycleState#7
// Offset 225
#BEGIN FMT_COMMENT 
"    5. Start lockout time for transition<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection.<br>"
"        * Transitioning is not allowed while lockout<br>"
"           timer is powered and != Done."
#END

STR	STKC40
ANDGT	STKD40	0
STRNE	D2	STKD45
TMRA	STKT40	STKD40

// Rung stkr_CycleState#8
// Offset 236
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Error Trapping ###########################<br>"
"#########################################<br> <br>    6. "
"Test for timeout on state transition<br>"
"        * If the machine takes too long between transitions "
"it is <br>          considered in a broken state.<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection."
#END

STR	STKC40
ANDGT	STKD41	0
STRNE	D2	STKD45
TMRA	STKT41	STKD41

// Rung stkr_CycleState#9
// Offset 247
STR	STKC40
AND	STKT41.Done
ANDGT	STKD41	0
AND	X319
SET	STKC122

// Rung stkr_CycleState#10
// Offset 255
#BEGIN FMT_COMMENT 
" <br>    7. Test for mised Latch Cam Cycle.<br>"
"        * If the Latch Cam Cycle Open bit is still set<br>"
"          that means the latch came cycle was not<br>"
"          handled (our cycle was too slow)"
#END

STR	STKC43
AND	X319
SET	STKC123
RST	STKC43

// Rung stkr_CycleState#11
// Offset 259
#BEGIN FMT_COMMENT 
" "
#END

STR	ST1
MATH	D2	"STKD45"

// End of Code Block stkr_CycleState
$TSKEND	stkr_CycleState

// Beginning of Code Block stkr_BufferY
$TSK	stkr_BufferY

// Rung stkr_BufferY#1
// Offset 0
STR	STKC10
ONDTMR	STKT15	STKD15	STKC15
ANDNDPF
OFFDTMR	STKT16	STKD16	STKC16

// Rung stkr_BufferY#2
// Offset 8
STR	STKC11
ONDTMR	STKT17	STKD17	STKC17
ANDNDPF
OFFDTMR	STKT18	STKD18	STKC18

// Rung stkr_BufferY#3
// Offset 16
STR	STKC12
ONDTMR	STKT19	STKD19	STKC19
ANDNDPF
OFFDTMR	STKT20	STKD20	STKC20

// Rung stkr_BufferY#4
// Offset 24
STR	STKC13
ONDTMR	STKT21	STKD21	STKC21
ANDNDPF
OFFDTMR	STKT22	STKD22	STKC22

// Rung stkr_BufferY#5
// Offset 32
STR	STKC14
ONDTMR	STKT23	STKD23	STKC23
ANDNDPF
OFFDTMR	STKT24	STKD24	STKC24

// Rung stkr_BufferY#6
// Offset 40
STR	STKC15
OR	STKC16
OUT	Y12

// Rung stkr_BufferY#7
// Offset 43
STR	STKC17
OR	STKC18
OUT	Y11

// Rung stkr_BufferY#8
// Offset 46
STR	STKC19
OR	STKC20
OUT	Y10

// Rung stkr_BufferY#9
// Offset 49
STR	STKC21
OR	STKC22
OUT	Y9

// Rung stkr_BufferY#10
// Offset 52
STR	STKC23
OR	STKC24
OUT	Y5

// Rung stkr_BufferY#11
// Offset 55
NOP

// End of Code Block stkr_BufferY
$TSKEND	stkr_BufferY

// Beginning of Code Block TestNewStker
$PRGRM	TestNewStker

// Rung TestNewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"##################################################<br>"
"## Tests  ##########################################<br>"
"##################################################<br> "
"<br>##################################################<br> "
"<br>Initialize Variables<br>##################################################"
#END

STRPD	ST1
RSTR	C400	C449
RSTR	C600	C649
SET	STKC31

// Rung TestNewStker#2
// Offset 7
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Set Up Mocks<br>"
"#################################################<br> "
"<br>    Mock Stacker Start"
#END

STR	C408
ENTASK	mock_stkrStart	0x0	0	0x1
NOT
HALT	mock_stkrStart

// Rung TestNewStker#3
// Offset 14
STR	STKC100
RST	C408

// Rung TestNewStker#4
// Offset 16
#BEGIN FMT_COMMENT 
"    Mock Stacker Cycle"
#END

STR	C406
ENTASK	mock_stkrCycle	0x0	0	0x1
NOT
HALT	mock_stkrCycle

// Rung TestNewStker#5
// Offset 23
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Run Tests<br>"
"#################################################<br> "
"<br>    1. Mock Stacker Reset State"
#END

STRPD	ST1
ANDN	C600
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"

// Rung TestNewStker#6
// Offset 35
#BEGIN FMT_COMMENT 
"    2. Mock Turn on Stacker"
#END

STRPD	ST1
ANDN	C600
SET	C408

// Rung TestNewStker#7
// Offset 39
STR	STKC100
SET	C600

// Rung TestNewStker#8
// Offset 41
NOP

// Rung TestNewStker#9
// Offset 42
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Pre-Run Error<br>"
"#################################################<br> "
"<br>    2. Make sure Run State stopped and error was raised "
"before restarting<br>"
"        * Mock restart stacker already clears errors."
#END

STR	C600
ANDN	C601
ANDN	STKC100
AND	STKC120
SET	C408

// Rung TestNewStker#10
// Offset 47
#BEGIN FMT_COMMENT 
"    1. Mock Pre-run error<br>"
"        * make sure stacker is running for this test"
#END

STR	C600
ANDN	C601
ANDN	C409
AND	STKC100
RST	X1
SET	C409

// Rung TestNewStker#11
// Offset 53
#BEGIN FMT_COMMENT 
"     3. Confirm error cleared and stacker restarted"
#END

STR	C600
ANDN	C601
AND	X1
AND	C409
AND	STKC100
SET	C601
RST	C409

// Rung TestNewStker#12
// Offset 60
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Run-Time Error<br>"
"#################################################<br> "
"<br>    2. Clear error and attemp restart, which should "
"fail due<br>"
"         the stacker not being a Reset State.  Use a timer "
"to<br>         confirm the Mock Start Up had time to try "
"and start."
#END

STR	C601
ANDN	C602
AND	C409
RST	STKC123
ANDN	STKC123
SET	C408
TMR	T200	1000

// Rung TestNewStker#13
// Offset 68
#BEGIN FMT_COMMENT 
"    1. Set cycle state to something other than reset<br>"
"        so stacker error can't be cleared.  Then mock error."
#END

STR	C601
ANDN	C602
DUPBOOL
ANDPDPF
ANDNE	D50	3
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
ANDE	D50	3
SET	STKC123
SET	C409

// Rung TestNewStker#14
// Offset 92
#BEGIN FMT_COMMENT 
"    3. If the timer experied and the stacker still hasn't "
"started<br>        we can be confident it won't start in "
"when the cycle is<br>        not in a Reset State."
#END

STR	C601
ANDN	C602
AND	T200.Done
ANDN	STKC100
SET	C410

// Rung TestNewStker#15
// Offset 97
#BEGIN FMT_COMMENT 
"    5. Confirm the Stacker Cycle is now in a Reset State "
"and <br>        attempt to start again."
#END

STR	C601
ANDN	C602
AND	C410
ANDE	D50	0
SET	C408

// Rung TestNewStker#16
// Offset 105
#BEGIN FMT_COMMENT 
"    4. Mock setting the Cycle State to the Reset State.<br>"
"        Stop the Mock Restart from running."
#END

STR	C601
ANDN	C602
AND	C410
ANDNE	D50	0
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
RST	C408

// Rung TestNewStker#17
// Offset 122
#BEGIN FMT_COMMENT 
"    6. Confirm start was successful this time."
#END

STR	C601
ANDN	C602
ANDN	STKC123
AND	C410
AND	STKC100
SET	C602
RSTR	C409	C410

// Rung TestNewStker#18
// Offset 130
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Detect States Test<br>"
"#################################################<br> "
"<br>     1. Mock each Cycle State one by one."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	tst_mock_stkr	0x1	DST511	"3 1 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	tst_mock_stkr	0x1	DST511	"3 2 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C412
ANDN	C413
CALL	tst_mock_stkr	0x1	DST511	"3 4 D50 1"	"3"
POPBOOL
AND	C413
ANDN	C414
CALL	tst_mock_stkr	0x1	DST511	"3 5 D50 1"	"3"

// Rung TestNewStker#19
// Offset 207
#BEGIN FMT_COMMENT 
"    2. Test every scan to confirm the Cycle State was "
"changed to the <br>         next state."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
ANDE	D12	0
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
ANDE	D12	1
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
ANDE	D12	1
SET	C411
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
ANDE	D12	2
SET	C412
POPBOOL
DUPBOOL
AND	C412
ANDN	C413
ANDE	D12	3
SET	C413
POPBOOL
AND	C413
ANDN	C414
ANDE	D12	-1
SET	C414

// Rung TestNewStker#20
// Offset 260
#BEGIN FMT_COMMENT 
"    3. Detect the state so it can be tested next scan."
#END

STR	C602
ANDN	C603
CALL	Stkr_DetectState	0x1	DST511	"3"	"3 STKD42 D12 1"

// Rung TestNewStker#21
// Offset 271
#BEGIN FMT_COMMENT 
"    4. Confirm all states have been detected once."
#END

STR	C602
ANDN	C603
AND	C409
AND	C410
AND	C411
AND	C412
AND	C413
AND	C414
SET	C603
RSTR	C409	C414

// Rung TestNewStker#22
// Offset 282
NOP

// Rung TestNewStker#23
// Offset 283
NOP

// Rung TestNewStker#24
// Offset 284
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Set States Test<br>"
"#################################################<br> "
"<br>    1. Set each Cycle State one by one after each state "
"has been<br>        confirmed."
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
CALL	Stkr_SetState	0x0	DST511	"3 0 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	Stkr_SetState	0x0	DST511	"3 1 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	Stkr_SetState	0x0	DST511	"3 2 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
CALL	Stkr_SetState	0x0	DST511	"3 3 STKD43 1"	"3"
POPBOOL
AND	C412
ANDN	C413
CALL	Stkr_SetState	0x0	DST511	"3 4 STKD43 1"	"3"

// Rung TestNewStker#25
// Offset 353
#BEGIN FMT_COMMENT 
"    2. Test each cycle to see a state has been "
"successfully set"
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
AND	Y12
ANDN	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
AND	Y12
AND	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
ANDN	Y12
AND	Y11
AND	Y10
ANDN	Y9
ANDN	Y5
SET	C411
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
ANDN	Y12
ANDN	Y11
AND	Y10
AND	Y9
ANDN	Y5
SET	C412
POPBOOL
AND	C412
ANDN	C413
AND	Y12
ANDN	Y11
ANDN	Y10
AND	Y9
AND	Y5
SET	C413

// Rung TestNewStker#26
// Offset 402
#BEGIN FMT_COMMENT 
"    3. Confirm all states have been set at least once."
#END

STR	C603
ANDN	C604
AND	C409
AND	C410
AND	C411
AND	C412
AND	C413
SET	C604
RSTR	C409	C413

// Rung TestNewStker#27
// Offset 412
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Cycle State<br>"
"#################################################<br> <br> "
#END

NOP

// Rung TestNewStker#28
// Offset 413
#BEGIN FMT_COMMENT 
"    2. Delay starting the Cycle Mock to test that the "
"Cycle Task<br>"
"        can run without the machine on.  In production the "
"Task<br>        will always turn on before the machine and "
"will wait for the first <br>        Latch Cam Cycle to "
"trigger its logic."
#END

STR	C604
ANDN	C605
ANDN	STKC31
DUPBOOL
AND	ST1
TMR	T201	2000
POPBOOL
DUPBOOL
AND	ST1
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
AND	T201.Done
AND	ST1
SET	C406

// Rung TestNewStker#29
// Offset 446
#BEGIN FMT_COMMENT 
"    1. Turn on the stkr_CycleState state task for testing"
#END

STR	C604
ANDN	C605
AND	STKC31
RST	STKC31

// Rung TestNewStker#30
// Offset 450
STR	C604
ANDN	C605
MATH	D6	"(CT0.Acc == CT1.Acc) && (CT0.Acc == CT2.Acc) && (CT0.Acc == CT3.Acc) && (CT0.Acc == CT4.Acc)"

// Rung TestNewStker#31
// Offset 472
#BEGIN FMT_COMMENT 
" "
#END

STR	C604
ANDN	C605
AND	STKC100
ANDE	CT0.Acc	4
ANDE	D6	1
SET	C605
RST	C420
RST	C406

// Rung TestNewStker#32
// Offset 486
STR	ST1
STR	ST0
CNT	CT6	D80

// End of Code Block TestNewStker
$PGMEND	TestNewStker

// Beginning of Code Block mock_stkrStart
$TSK	mock_stkrStart

// Rung mock_stkrStart#1
// Offset 0
STR	C407
RST	X8

// Rung mock_stkrStart#2
// Offset 2
#BEGIN FMT_COMMENT 
"Turn On Stacker"
#END

STRPD	ST1
SET	X1
RST	X32
RST	X2
SET	X8
OUT	C407
SET	X16

// End of Code Block mock_stkrStart
$TSKEND	mock_stkrStart

// Beginning of Code Block mock_stkrCycle
$TSK	mock_stkrCycle

// Rung mock_stkrCycle#1
// Offset 0
#BEGIN FMT_COMMENT 
"1. Initialize stacker Cycle State to the Reset State"
#END

STRPD	ST1
DUPBOOL
ANDNE	STKD42	0
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
ANDNE	STKD43	0
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
POPBOOL
AND	ST1
MATH	D27	"6000"
RST	C427

// Rung mock_stkrCycle#2
// Offset 42
#BEGIN FMT_COMMENT 
"2. Mock the cam cycling"
#END

STR	ST1
FLASHER	100	D27	C420

// Rung mock_stkrCycle#3
// Offset 47
STR	ST1
DUPBOOL
AND	C420
SET	X17
POPBOOL
ANDN	C420
RST	X17

// Rung mock_stkrCycle#4
// Offset 54
#BEGIN FMT_COMMENT 
"3. Mock the input values for each Cycle State after the "
"<br>        outputs reach the corrosponding Cycle State."
#END

STR	ST1
DUPBOOL
AND	Y12
ANDN	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 0 D50 1"	"3"
OUT	C421
POPBOOL
DUPBOOL
AND	Y12
AND	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 1 D50 1"	"3"
OUT	C422
POPBOOL
DUPBOOL
ANDN	Y12
AND	Y11
AND	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 2 D50 1"	"3"
OUT	C423
POPBOOL
DUPBOOL
ANDN	Y12
ANDN	Y11
AND	Y10
AND	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
OUT	C424
POPBOOL
AND	Y12
ANDN	Y11
ANDN	Y10
AND	Y9
AND	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 4 D50 1"	"3"
OUT	C425

// Rung mock_stkrCycle#5
// Offset 147
#BEGIN FMT_COMMENT 
"    4. Count each new state set for testing.<br>"
"        <br>        * Count Reset State Set"
#END

STR	C421
STRPD	ST1
CNT	CT0	D20

// Rung mock_stkrCycle#6
// Offset 152
#BEGIN FMT_COMMENT 
"        * Count Ejection State Set"
#END

STR	C422
STRPD	ST1
CNT	CT1	D21

// Rung mock_stkrCycle#7
// Offset 157
#BEGIN FMT_COMMENT 
"        * Count Compression State Set"
#END

STR	C423
STRPD	ST1
CNT	CT2	D22

// Rung mock_stkrCycle#8
// Offset 162
#BEGIN FMT_COMMENT 
"        * Count Transition State Set"
#END

STR	C424
STRPD	ST1
CNT	CT3	D23

// Rung mock_stkrCycle#9
// Offset 167
#BEGIN FMT_COMMENT 
"        * Count Load State Set"
#END

STR	C425
STRPD	ST1
CNT	CT4	D24

// Rung mock_stkrCycle#10
// Offset 172
#BEGIN FMT_COMMENT 
"    5. Count each transition for testing."
#END

STR	C413
STRPD	ST1
CNT	CT5	D25

// Rung mock_stkrCycle#11
// Offset 177
#BEGIN FMT_COMMENT 
"    6. Random Transition Offset"
#END

STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
ANDGT	STKD40	0
ANDPDPF
MATH	D26	"(((STKD41 - 5) - STKD40) * RANDREAL()) + STKD40"
SET	C427

// Rung mock_stkrCycle#12
// Offset 202
STR	ST1
STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
TMRA	T202	D26

// End of Code Block mock_stkrCycle
$TSKEND	mock_stkrCycle

// Beginning of Code Block Run
$PRGRM	Run

// Rung Run#1
// Offset 0
NOP

// End of Code Block Run
$PGMEND	Run

// Beginning of Code Block Glue
$PRGRM	Glue

// Rung Glue#1
// Offset 0
STR	X58
ANDN	X59
OUT	Y54

// Rung Glue#2
// Offset 3
STRN	X58
AND	X59
AND	STKC42
AND	X62
OUT	Y55

// Rung Glue#3
// Offset 8
STR	Y54
OR	Y55
AND	ST2
OUT	Y69

// Rung Glue#4
// Offset 12
STRN	X16
OFFDTMR	T0	1400	C0

// Rung Glue#5
// Offset 16
STR	X16
AND	STKC42
OR	Y72
ANDN	T0.Done
AND	ST2
OUT	Y72

// End of Code Block Glue
$PGMEND	Glue

// Beginning of Code Block tst_stkBufferY
$TSK	tst_stkBufferY

// Rung tst_stkBufferY#1
// Offset 0
STRPD	ST1
RSTR	C409	C413
RSTR	STKC15	STKC24
RSTR	C610	C615

// Rung tst_stkBufferY#2
// Offset 8
#BEGIN FMT_COMMENT 
"Make sure output is off"
#END

STR	C409
ANDN	C414
TMR	T1	D30
TMR	T2	D31
SET	C410

// Rung tst_stkBufferY#3
// Offset 15
STR	C413
STR	ST2
CNT	CT7	D0

// Rung tst_stkBufferY#4
// Offset 19
#BEGIN FMT_COMMENT 
"#####################################<br>"
"## Run Test ###########################<br>#####################################<br>"
" <br> <br> <br>Test Vertical Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STRN	C610
SET	STKC10
ANDPDPF
SET	C409
MATH	D30	"STKD15 + 500"
MATH	D31	"STKD16 + 500"

// Rung tst_stkBufferY#5
// Offset 39
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STRN	C610
AND	C410
AND	T1.Done
RST	STKC10

// Rung tst_stkBufferY#6
// Offset 43
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STRN	C610
STRPD	STKC10
ORND	STKC10
ANDSTR
OUT	C413

// Rung tst_stkBufferY#7
// Offset 50
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STRN	C610
AND	C410
AND	STKC10
STRN	STKT15.Done
AND	Y12
AND	ST1
STRN	STKT15.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT15.Done
ANDN	Y12
AND	ST1
ORSTR
STR	STKT16.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#8
// Offset 69
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STRN	C610
AND	C410
ANDN	STKC10
STRN	STKT16.Done
ANDN	Y12
AND	ST1
STR	STKT16.Timing
ANDN	Y12
AND	ST1
ORSTR
STR	STKT16.Done
AND	Y12
ANDN	C413
AND	ST1
ORSTR
STR	STKT15.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#9
// Offset 90
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STRN	C610
AND	C410
ANDN	STKC10
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C610
RSTR	C409	C413
OUT	C414

// Rung tst_stkBufferY#10
// Offset 100
#BEGIN FMT_COMMENT 
"Test Ejection Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C610
ANDN	C611
SET	STKC11
ANDPDPF
SET	C409
MATH	D30	"STKD17 + 500"
MATH	D31	"STKD18 + 500"

// Rung tst_stkBufferY#11
// Offset 121
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C610
ANDN	C611
AND	C410
AND	T1.Done
RST	STKC11

// Rung tst_stkBufferY#12
// Offset 126
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C610
ANDN	C611
STRPD	STKC11
ORND	STKC11
ANDSTR
OUT	C413

// Rung tst_stkBufferY#13
// Offset 134
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C610
ANDN	C611
AND	C410
AND	STKC11
STRN	STKT17.Done
AND	Y11
AND	ST1
STRN	STKT17.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT17.Done
ANDN	Y11
AND	ST1
ORSTR
STR	STKT18.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#14
// Offset 154
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C610
ANDN	C611
AND	C410
ANDN	STKC11
STRN	STKT18.Done
ANDN	Y11
AND	ST1
STR	STKT18.Timing
ANDN	Y11
AND	ST1
ORSTR
STR	STKT18.Done
AND	Y11
ANDN	C413
AND	ST1
ORSTR
STR	STKT17.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#15
// Offset 176
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C610
ANDN	C611
AND	C410
ANDN	STKC11
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C611
RSTR	C409	C412

// Rung tst_stkBufferY#16
// Offset 186
#BEGIN FMT_COMMENT 
"Test Compression Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C611
ANDN	C612
SET	STKC12
ANDPDPF
SET	C409
MATH	D30	"STKD19 + 500"
MATH	D31	"STKD20 + 500"

// Rung tst_stkBufferY#17
// Offset 207
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C611
ANDN	C612
AND	C410
AND	T1.Done
RST	STKC12

// Rung tst_stkBufferY#18
// Offset 212
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C611
ANDN	C612
STRPD	STKC12
ORND	STKC12
ANDSTR
OUT	C413

// Rung tst_stkBufferY#19
// Offset 220
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C611
ANDN	C612
AND	C410
AND	STKC12
STRN	STKT19.Done
AND	Y10
AND	ST1
STRN	STKT19.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT19.Done
ANDN	Y10
AND	ST1
ORSTR
STR	STKT20.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#20
// Offset 240
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C611
ANDN	C612
AND	C410
ANDN	STKC12
STRN	STKT20.Done
ANDN	Y10
AND	ST1
STR	STKT20.Timing
ANDN	Y10
AND	ST1
ORSTR
STR	STKT20.Done
AND	Y10
ANDN	C413
AND	ST1
ORSTR
STR	STKT19.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#21
// Offset 262
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C611
ANDN	C612
AND	C410
ANDN	STKC12
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C612
RSTR	C409	C412

// Rung tst_stkBufferY#22
// Offset 272
#BEGIN FMT_COMMENT 
"Test Transfer Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C612
ANDN	C613
SET	STKC13
ANDPDPF
SET	C409
MATH	D30	"STKD21 + 500"
MATH	D31	"STKD22 + 500"

// Rung tst_stkBufferY#23
// Offset 293
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C612
ANDN	C613
AND	C410
AND	T1.Done
RST	STKC13

// Rung tst_stkBufferY#24
// Offset 298
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C612
ANDN	C613
STRPD	STKC13
ORND	STKC13
ANDSTR
OUT	C413

// Rung tst_stkBufferY#25
// Offset 306
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C612
ANDN	C613
AND	C410
AND	STKC13
STRN	STKT21.Done
AND	Y9
AND	ST1
STRN	STKT21.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT21.Done
ANDN	Y9
AND	ST1
ORSTR
STR	STKT22.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#26
// Offset 326
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C612
ANDN	C613
AND	C410
ANDN	STKC13
STRN	STKT22.Done
ANDN	Y9
AND	ST1
STR	STKT22.Timing
ANDN	Y9
AND	ST1
ORSTR
STR	STKT22.Done
AND	Y9
ANDN	C413
AND	ST1
ORSTR
STR	STKT21.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#27
// Offset 348
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C612
ANDN	C613
AND	C410
ANDN	STKC13
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C613
RSTR	C409	C412

// Rung tst_stkBufferY#28
// Offset 358
#BEGIN FMT_COMMENT 
"Test Load Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C613
ANDN	C614
SET	STKC14
ANDPDPF
SET	C409
MATH	D30	"STKD23 + 500"
MATH	D31	"STKD24 + 500"

// Rung tst_stkBufferY#29
// Offset 379
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C613
ANDN	C614
AND	C410
AND	T1.Done
RST	STKC14

// Rung tst_stkBufferY#30
// Offset 384
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C613
ANDN	C614
STRPD	STKC14
ORND	STKC14
ANDSTR
OUT	C413

// Rung tst_stkBufferY#31
// Offset 392
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C613
ANDN	C614
AND	C410
AND	STKC14
STRN	STKT23.Done
AND	Y5
AND	ST1
STRN	STKT23.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT23.Done
ANDN	Y5
AND	ST1
ORSTR
STR	STKT24.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#32
// Offset 412
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C613
ANDN	C614
AND	C410
ANDN	STKC14
STRN	STKT24.Done
ANDN	Y5
AND	ST1
STR	STKT24.Timing
ANDN	Y5
AND	ST1
ORSTR
STR	STKT24.Done
AND	Y5
ANDN	C413
AND	ST1
ORSTR
STR	STKT23.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#33
// Offset 434
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C613
ANDN	C614
AND	C410
ANDN	STKC14
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C614
RSTR	C409	C412

// Rung tst_stkBufferY#34
// Offset 444
NOP

// End of Code Block tst_stkBufferY
$TSKEND	tst_stkBufferY

#BEGIN ELEMENT_DOC
"X1","","","Air SW on Stacker"
"X2","","","Air Pressure OK"
"X8","","","Stacker Reset PB"
"X16","","","Machine Run Started"
"X17","","","Latch Cam Start Cycle"
"X18","","","Eject In"
"X19","","","Eject Out"
"X20","","","Transfer Operator Side"
"X21","","","Transfer Drive Side"
"X25","","","Operator Side Load In"
"X27","","","Operator Side Load Out"
"X32","","","Guard Door SW"
"X58","","","Tape Glue Manual"
"X59","","","Tape Glue Auto"
"X62","","","Machine In Run"
"Y0","","","Stacker Jam Light"
"Y2","","","Timing Fault Light"
"Y4","","","Gradual Start Valve"
"Y5","","","Operator Side Load Sol"
"Y9","","","Transfer Sol"
"Y10","","","Compression Sol"
"Y11","","","Ejection Sol"
"Y12","","","Vertical Bar Sol"
"Y17","","","Machine Stop Interlock"
"Y54","","","Tape Glue SOL Manual"
"Y55","","","Tape Glue SOL Auto"
"Y69","","","Tape Glue Pump On"
"Y72","","","Tape Power Relay"
"C200","","","Enable Stacker Program"
"C201","","","Enable Glue Program"
"C203","","","Enable Stacker Test"
"C400","","","Mock Stacker Operation Pre-Run State"
"C401","","","Mock Stacker Operation Reset State"
"C402","","","Mock Stacker Operation Ejection State"
"C403","","","Mock Stacker Operation Compression State"
"C404","","","Mock Stacker Operation Transfer State"
"C405","","","Mock Stacker Operation Load State"
"C406","","","Mock Stacker Operation Cycle"
"C407","","","Mock Turn On Stacker"
"C408","","","Mock Restart Stacker"
"C600","","","Passed Stacker On Test"
"C601","","","Passed Stacker Pre- Run Error Test"
"C602","","","Passed Stacker Runtime Error Test"
"C603","","","Passed Stacker Detect State Test"
"C604","","","Passed Stacker Set State"
"C605","","","Passed Stacker Set State"
"D30","","","Vertical Bar On Buffer"
"D31","","","Ejection On Buffer"
"D32","","","Compression On Buffer"
"D33","","","Transfer On Buffer"
"D34","","","Load On Buffer"
"D40","","","Vertical Bar Off Buffer"
"D50","","","Stacker Operation Mock State"
"STKC0","","","Eject In Eye Buffer"
"STKC1","","","Eject Out Eye Buffer"
"STKC2","","","Transfer Drive Side Eye Buffer"
"STKC3","","","Transfer Operator Side Eye Buffer"
"STKC4","","","Load In Eye Buffer"
"STKC5","","","Load Out Eye Buffer"
"STKC10","","","Stacker Operation Vertical Bar SOL Buffered"
"STKC11","","","Stacker Operation Ejection SOL Buffered"
"STKC12","","","Stacker Operation Compression SOL Buffered"
"STKC13","","","Stacker Operation Transfer SOL Buffered"
"STKC14","","","Stacker Operation Load SOL Buffered"
"STKC30","","","Stacker Reset Press"
"STKC31","","","Stacker Cycle Disconnect"
"STKC40","","","Begin Timers"
"STKC41","","","Transition State"
"STKC42","","","Stacker Start Up Cycle Delay"
"STKC43","","","Latch Cycle Open"
"STKC100","","","Stacker Run State"
"STKC120","","","Stacker Pre Run Error State"
"STKC121","","","Stacker Run Time Error State"
"STKC122","","","Stacker Operation Transition State Timeout Error"
"STKC123","","","Stacker Operation Missed Cam Latch Cycle Error"
"STKD40","","","Stacker Operation Transition Lock Out ms"
"STKD41","","","Stacker Opertation Transition Time Out ms"
"STKD42","","","Stacker Operation Detected State"
"STKD43","","","Stacker Operation State Set"
"STKD45","","","Stacker Operation Next Cycle State"
#END

