// Options: Export entire program; Code Block delimiter instructions;
// Formatted Rung Comments; Element Documentation Database; System Configuration;
// Memory Configuration/Devices with Built-In Types and User Add-Ons;
// use Element names (no NickNames); rung/address annotations;
// <TAB> parameter delimiter; 
// Write/overwrite file C:\Users\jmarshall\source\BlueMachinePLC\BlueMachine_EXPORT_DMD.txt

PLC DM-SIM

// Do not modify SYS_CONFIG block!
#BEGIN SYS_CONFIG
df6992a3514b9dd13f34bac4f1da8f61ac0388a93b27293d62cc840c607e224d193c89081bb82c67
6369881b1b90233fb8ebde5a9fe62bd5c86438bcc1720fa83830303b228a6e1d5b807836a88f0938
80d0a4f21cbdb33255552a1e6ed64f86b3bed30bcef7584eff051620c4bae7922c2c9d20b3f5afcc
0a1815dd5b4690319b8a1c62c8526b943ed5068c9c7bb1dc8c17379373182a02e0fa9142a4ecf5b2
da98c9bd56bb75b677e975de46c92e7ee9236c2d017d5712ba677e609eb39c994669ea4954962c1c
6d6b95b93013a8345a07cc63a2ca3b85a0a977bd935eae0f34e483e6f54aaa141028774451ac1481
3b6fa0dd50432e2e5812da528c78d877e1717856cff3e2f3ac83ec630ea2d0baa27b68a59ed0deb5
3e2c04123a7683b78df99eb62c1b4f92bf685412b2d961d33b237484d2129438176bc6cb2f632077
6a699a7deab24ba0d4ee7b3eaa5121ff090a8d40b2fafc8f9d5aaaf22cd661016aaebed85ada0160
2d0a4a363ff0239b345c3ce1e9b47ab370073e75e9a970fac2104e66069ac5e065f3cfb691d6474b
6cedbb834407f57908d11bd38257600ef26737ac1c0544cef93c94244f1a9b7c614e72b0632dfd2e
4155a4f3c88d0df62046bff16eccf37445463f5ef1dd4fb8c5f2f7ebec7095190532a9e0ee370a30
2411e6181714b81d9b6b2f2c6844b9a50cea0e97bf6a51292b914ed9da4dabe22e7b4e0a35a498d6
02195b5667162ebccb76a401cc41d3000b990451675cc79be61a83d71a135e937fe8de68600873bf
b0ffea8a8009803925104da15bde7fddeb03ed7ce4b8e6dbb02cf292dc14c3e0ad9b3cbb7865d890
3fb7d590bb902b10d8ce4fe1d2a937676e4441a1347ebf20a7577f612ac5cd933e597b21c10a40e4
fbc6efa4517e886c8916a45f0ca751373757e3ed1b0a97984a3d5fbd21821b7460808061f6b5acdd
cf8a07e47da4183f8fc154c0b18ee8c55713c31ec7091e47d28df5231e75789fe067224c889afadb
3f29aea7188169ce32749e340a5bf7c2c6288519f2a5f4ba3bbde40f9cce668c3b98391b93a17bff
5ad89eded26d87d745c65367108c25a3dca41d5410dcbbcb311134bb9ec9d68c7722e889a9b313f5
a59248746714cc336920d8ffc48c8f2b1d3dc8b4e7c701c049ba9a7a4efb78a727c715186fa96a32
e6bf5f392e2635acdcfd0de04ae86c0c4e3526de4b944351461bd972bdc37cf1841f6bf7a95c8dc3
4e1be62a62dcdfa06ded2dbdff7a2673bbf967d8889fbb7c5f8a9358e8a2877a485bebec3d552480
bc3bccd97d3ac0c77d9243aad404eef5288bf91c1b2a1c6a8fd164026908558060f655abb421b864
8a2be4483fabb7fa51483f52161bd76ec557e310b0100437ca36d7d2a82051ae0f096ce9a8da7907
2ee315d2020a9212d80ff0506b196d3ccd8e32cae79e11cc206f654cf8f9208093ec7bf47edeb494
282571c15f38ccb5eccaef6eb97a4659c06a12f4f197474508eafd30669a74d2d47030e001f2cfb8
ba180f63de47a07f198fde68a7e51b91b0715178e0f7b0e5189b9ac86483cdeb2878dd70f4fc9100
db81cd6c5b3868adb52021a05b6a7eec49e7a11b51d3eb5dc270db2180add0f2546380099650ee64
21292de15675736cc3ed6efc0885791b65a7ee113c6e6a2d9b22f2c76a33b92c382fdeba057af0a3
34c82d5c79a944c1ec1a3f9b8e7a6e471f80c29cf23beb20dd877239e18c1c75be2caca2c6694e83
fe9f9d43497267fe0752240923b2b7ab2a325d5ed6c3362271fbc4f7e27b8277016c414c1566ee7f
434bc3d6231738981dea8baf732a8f4dafbf99c1802473d5b1cb5b0cee1412ce7a87f7e3ef36f489
c1ace8b0ea9cf5fa584043377ef591018167173679238b1cc4f4452a1e73acea774ef46b81eb255e
ccaa75ae6ce2e00fde4ef569d0dcb0a9f07d45eaa312ceb0411a78f01d4939cc95f1a9989ec449cc
4859608c43e4e898b6fc2f2c059526a78b5837c87a9c9006db798370b02f0e967bb72566f3c97b17
2fe49bc7742b3b145694f4b512da5225fb8a98e06f9c37884afef360823a5adf10a153026c79e03e
dcf1e7b21be3dc9b047a603a5b796940fff09b3a97d082308b6e95a6a3020e8995568d841e96ec49
dfeaa43e849019221165912956d0cc1777b69f0147f773cb8504b0578ae9dfb43bc15569e1f78d30
57a7a209cf73e352374f11b71035b622029051c3e338a52500f4402fbe9d2b5a962bb4ec46ddf1b2
7df3be888d19d1f5f0c8e1f268219bffdb7e3b4946012da5824017fd2b9b6cc7810034567722cf90
38b7781a3f74192a6a9edaea9b0e738bf38c71a21900d22e283254746b593148da08f42fc33ae377
9819e7f86e7e409b6f883af8952cf129d61eeb1d5b9fcac589051c123abf28bfe86750f48582c36c
fe22670909181e83e3eb98aee9c883813a371f5827c6e7e980bfa4471a1f06bb7b2e1c57d59b2257
e75a15b15a805034a495233195b772f4885f0844b7db64ccd07161dc396def148099af11ba88d42b
19cd8d09a142c32982828cf10e3aaacb6eaea645603b127d6bf99be1c9fed4fd093bcf0f89e1fc04
a296869042b94315de60a07ea0a6f7e6a3f6fec11735b1f63f3f1456a5d16b4ce3e45d344ec8f3a2
93c5ae6081d53961081f78986e72d746dc25441c3f21c29a81992955fa3f0c5db0b850de33af9555
014ce172ebb5ad1780c1c18ad5b2ccf7f0248fd1b64a2edd7b5201dc27e3acdc6a58c0f2f3fd5e24
f47899e7e3e25caae369b1aaeac0e741c688ba692693c09c8b21ba71864e4eb7cdd02ef06fcb9dcc
ad9c6c144b1a1be0cdf5ae435216e54f22fba21d6c98ef00e6e3ae29ad10dd248f23dfe6a1e70935
9819a9f257cef02c9966867ab6b8edacfa7c5cd101fe6815ab718c04a80f91b0481a1205ecba5619
70626b7c4aca03556ab16327bfa5cbc74563f3c9ed8feca107b8732947312941224d831d74e06577
3413aef2d45f57eb93c9f4f6c6948785b0a96a53e0ef7ebd0ae5ea4322bef2720a39cc112e50bd15
00efe41789fc234865ecbcafe2c75849b0c9eeb7b8e16d2d4b76566d39c45bb635cc03b326c13824
8540aca6c0dda5e50d0ddef33ca500771e4ef0fe248adaf08a784a5899bf384ab7ccaf171f6817b2
e8d03b4c176683192838258c4ed96f684eb0d51e72f8d5c25555b59a18f9cb44719e7a5a3b84b1f2
5f22274c32e4d77a5a5db10d8c103498964d5d0f07143fe61ae030ed72f0fba81d7d35a090d0db91
896ba2eab46e7b44c42ab7947c02ebdb055c7d9f4242df82328812da8b5ddaa5803f1f37a6035036
ac87204bcb8a6f7868fabdcf1a3ae3a6bf62fd5e9cba6f8f3ad9f5d75292e6d0fe497d9d4ead5c6f
2f2ad7a17c01a2b16af9e603a2766059174fc9d461c4d373bf3fda02ebd5319a3492e8565f0f5876
070bf19a9ab09a8ed22565e5659a145531544a2c3d1768b04f864dfde646b4797a50730b3042cda8
2a5255a1f268ca3ed9ecaec9dbe350e9acc973d09ca7bc11d1a702cc4130415253f30b42ccc0ccb6
a5a1991056346b9ff7ab06d12988d4c5148e2f683a6cc5437ebdfa3b6452ca8b6c98c49d202b2e17
b0bb05da3f9864907c9ee350cc6d4ea889cde887185580c90044c8b5e09210686f8754f153a74055
172c986eae9c792944402424fe6eaaad1c8d9ebad832b54692a812adcd448e474028014348d28439
1a82984acc8b517d54d6ba93a212b566dae7c926d667c531d6eba9d48b2e7aa9ece16bbd6f0f1131
64e859f248816e7226d793d941c8d5e80a7c9d265e3250e78ceaadca51d2c45ec599a4da960684e5
0f88bb6d1ab1f6a4923098c8eb2e925259a9d45e955f48a664ebc591b43714ce7a3798ce78ab66cb
a554fcf7503a8e135d6b4434d6c59b94d6e551a76725c0b4940d8ed842d986bbc50999abfa657cf4
23990e6758e515058fb9d75c624c8dcc2bdf5da4b0221deb119ad252282dfd0d61f636516e2db460
ecf73473b2f0f2eb5f912f5cbd2a523e5c942f85067c79f18364a8d566fa7b58debc56d17a2ddc72
3567d171ed9fa9c74c527cd94c0cd0e9d35ad1c1bb648c1eed51434b5a57e1fa9d535a96bfe2cbb2
b1d894210e9d3dea9b44a637f80be5b52252ad50d884a0c8c80a671e8fcaa02842a974884cf6eb89
2bebfd84efa4c2209c9957e9d5f98db0e67f95cdcdbf20e0ccffb10632ce9d45e61a72d525e92f2f
d4597b696d178870a94cc090b9a41db8073ca5b5c583aed6935a71a8535177918ae88a3af457e704
74076b53bc0c6836b2966911765c351a25fd564fa41f8424ea665e5107e07889cd6a40db8065b6e4
73090d7d8f6e022e5a7fccef197e0b2a15ca6ab37c814c36635f4140143165cace2885266b504a67
8d039239f33a655703f0b4fbe3c58126d250a9e5d29c76d3d98478db0dddfde2189f68a8dfde0477
e8e74e5688d40deaf2a8cbcccbef0c7a42275e30c37388f9b0b70e49ab7b4f48c2d75fa274f2f17f
ffcb472a7000136c1899345fe56dc61b7459a4dd98a4bd4848daccc251f2b69b5e0ad0cfb63893e4
7e07ff2f9f75edfbedb21b34acbd620dc614995b890cc9642b84e9e378fd68086d1dbde5595ad82c
e37ef87ef1c5346c7c74cf195466929680aacb958b3e53c84e124ac8eb69df10984c01335932161a
cbae7488aba6ecd9d72307fccd9933829d3b4789a7f4f72af03ceaf2d647b755b6d4af10fa666e9f
567c15f74d0f9075f6a84139603543ae04fedf92cd876a3dc893cda13a7e68120c27d2b50e5ed090
58815aedb48ef3e6c1f6e3874c78fb5f8217b50556b7dc2170c825725e3392a8d6f9510bbf032fb8
34b70ffaccf93da28d9fcd102979f5fad1ff613310ebd6cd336c0d296fa03c321d055706cacc9d52
38b3cc7ea0369ad1c8520459624296e94b30d56577c1ea971023767044103509c5b043677bbc4562
ff1c07495968a339966591d8829bd48aae8445de65daa227103293f820954bad3b844438ce636717
68108368b357e0223d1c9462ad930b7779744f77891b32096fddb31f2cbf06449596c2bd0262895c
b34fdb220cbf76c972ef6e45cd7bc5f9bd35c135f9328a6d377ab48a078c5a386e46d925a54b7f98
e66a10a60c7b9750088bbcbf6bf2e95ec47da988967be41afa8bd84db910de5e082df3cd6dd2aa65
f77ecdcefcd9dcfc5e35a6a32e82f1b3fabca73d513241b1a5c99d6c2b989e737d3063910401d34b
a90f946753a60075b2bbfad2645fbcfbc1fc7503da2d86917588e3d55e2d51d3367c68d938e5de92
e4239d88de79b010dd429349d271ebf3752c62d9af31fb38df99e81e9056235d8d55b87ef24a083b
3e2e882ae20ab18c13ae866137a91a618e90bc6644a8c1f304ca1c02d047f459ff3b21790a148738
dd8669602989f2b46cc4a3cc9a04ff807c1285aad153303fa78bb8bc8beba23b8181bd180f1f2a49
322778c8bace5e9b0822a21a4f5095b650706459cd7466a551366c0f61c50e3f154b98d1096dab2c
07d88cb3f1b7ee7cd916c3bf100db6a1639da2f9a8c6544b6568fd5a8c8af5f06faf3e318373d3c2
0093943dfc041cad90a54a1b999ad2db6936661daf92f76f82aba2e5c1bbcda6baad7c5289089f2c
ed160f5a664d53313370a4cf47d7827a84f1c50897b017f8ac9e7e229d137c105e4f90753bf304d8
c52f082176af125212838479750dc6a0d3aa99430665122c1fd27bd94ea67703154fe5ee6af8e51b
a02437530d8e98a557765f1fd8ed58500fb8ce4ff7a2e18f967ec0424ade89c55cef7bafb2cf3400
15699a3bcc94b6f90be00e448d11c41d3aaab3692d08488a70755199aa1ce160b72bda61cb5842c7
f3b5d37e1f12a21e6a6003b1fdc8072244707bbf899cd205105f39a3e1593cfb23a8be560b528bf8
496731c909a366565503dbd6129d83b0f7b34a62dd71c3ec68ed3c18b8b2632309a5f03c8a08c213
d3137a02591369f9950b4bf9e2b7e5127703faf4970b54e6fcdef285b2c64f3077484966b4b0a478
271770f91b745117d763ff5ba2272f01877ff20c72981cbb9884de6c37caa344d01463eaf942e403
7f6c263c660ff68a1e4cdba46b626dace75e4d215320250ae99cd9f7069faa43ea5a223ddbb590da
5dddf9bf050c52fb84e7a00c39b96f5bae97dba512e60fac45d694ca218a7def80d2a3bb4d40f835
07bb38b55b8c894dae69d62bf1ecd7063e26d84726445ffb417479be9b0e70b73ecd939e914f66a3
37da4e46fdaa96c18f7c19042f3b0e2afff994978ab091e0f6204fe7ec1287fea2d1a7c1fa82980b
b8750f367f6673fc4c2be9a1b0cbdd975c31b65ec8d8a2423be4c61415486b064ec73a22c2acb9b1
c230596f33be648ccac6ea21800b6836c163407d0346a52a5b5178b58a01dfbacc342d1bf9ce24c9
c6027e5b1b4d5a14e85506d7574d9f4bfd09e351deb9e5364a4f92c30d1e6d2533f245514ef442f6
36ab4c926ba7ddf8b68875c5fa2df1a64fa29f3e0a68697b9a3087f201ba5300ef7b36bdc9fab46c
4d6fffc047a7155732c711b056d1fafef5841757cac179ddd767d764d73183a945a52e5f51d90b1b
c7b7db4bca7083b1428358bceacb2cc5e78c26e0ec961327c4e2648c5e0b6f291bb7e65bbe95e979
06659a275faf536358a32208b937744d17c4ee8524d693ef35e001d42eeb6c7609af07509bffce68
cdcbaf53e93eb4860d236a8885df3887cfe4a933fc70648bf6600571fe43d75efa7b43614128c908
7f9bcdbc74b81275db47fe10b5b3e0be36c1ae454a28e265b6745e7a0b9fda3a11dc4270338531a6
0a3cd52c400a3e95485b3a78881849472131fc2f81c07c255287c5cda428d9e2bbfff17073986298
76455cba0ec954ed412cfd8e33d668be3cfe0d5f26ff464b2768f9aa456aa26e2b19c8ed8e5c52b9
4eeb2bb3820d4b9034bb2d89b35b7659d7e8dbf4b40653cf30927bc8c8ab54059aadd22d8e44657a
23450a3aeeca84f1e378682072abf639c6499227a2181154a63f925b7fda7f3c9b95b34274aeb228
e3a45354a59a34151afead7cdcffdc62ef0f78be9202e6c5008dda489ab1ea9be08cc489718d3f8d
f71dee8f0e200d67d8d020bfcf516ff5bebc165782e8ece574c9ecd9f900cc056d9aa1e111606793
0eb3bfa1eddf6ea81ebf1de2e6abfbb7b2973a5e405f1bb8d105559a8b2211cc93493e074d11a2ed
f198dbc9aaac4a6f7ddeff9f62bb043641ce9dad65db8e286b94e07c3e186f3ae0e8b9595f9315b0
053c9275923cb018315dbcb7d8eec4b64455f50a6cee8a446f39e8a53d5c546a2124ee5984043a75
d6b6145349a401bd8969febb5a0b50effcbed3b3fa7426c56945729f0b4d833c4536758ec0bd02b2
6332a57c2b4d2256d05d5d7c7b3780d7886a04828d3aba370be0bd66258e5e3d18bb6e4ad010ebd4
ccaaa3914dbd779e30cca8e8a16b8c67973143882c7cdf19572b28ad0f2dfb11659d9c3666e5e0fe
fc3f1ad854340c3455999bf5d4b0220c569a1b1f741ced71af9579aa04a5f224c5c544a023b22ee3
6ed8498634c6bb9d3d70f80de552fb6907fa337efa2e7054507e7e4e6849bdc26ca1ca6ce1e5c463
5b2db7be3052d6596e5b3740bd3578f2f6627bd3e0a956a36720b1f9786087f678c7fe9b8bebc32d
34d37ad8a8845d12db2414f1360b4b561cfd3710749d8594ad3acdaba908d62aa2e4f1e45113e655
70b01eb6a909da7139b4232068b00cde951019d8886ed3158380c8f5815f1ced3decc7d35f43e6e5
6e6e2a0fa955f534bf68de8e03c2e2a762ec847d6dfade648e944e48ced45dacd68aabe90ff45c12
ea2590183019da51afcbaf0a42d6ee33c158931ea5c90482188e24cf8c9fb7354e9b515091d70e36
4b9ae5ed90bb18f01243a5ef837f5c5d82ca332d4316865c0ae6f733f568813dbfd1e7735735aa5a
bab33dbe260d088da7a46ad5131b01ee3dbd0749034aeb39d3da823dc5d71683a7d7f16951ef932c
c688810975fbcaab812a31975266fcc1eb381fa9c3ad71cb5cb5a6fdf0a05b5e5e70ca7e7eacb8c6
85f817851256dbd4f522615e2635575684decdd4182b3e71d8ead525592e1e7bbbfa3219a3acc567
4b40789169707fc8e1782eed8e0a0cf4db00f0f6d28cd409d5ed8b8c947024067449a34a227e92ca
42bc11303de71a6e2f52876f5ce7bc1a55feea855062826697dbb1f29289748b8bb36f05ff65bec6
f7ca2a769d07596489ef45747d9194d61bfdf774f3e15d68e319d7dc0ef36ff34775376d075cb3d8
5b6d84ca3b34e187b82a7ccb7fa5bd95c738e2ee897217c0fa8ea49b880ae831ef82d5d3e1f217f3
fe3b408c8d9f3c57bbf593693ccebad61d06bccc2a538e1b575728679327aabc225d9b760cd9d322
c207c5341b95feb531f063b3347dcebd7c849ff19727fb421469f2dd6204ed7611340523c56d73bd
fc32b6cd8df21484aa245e4d773587fb03cd387f378c2b1394ea667c2e12d9d1bed9240a8fdbd0f0
2445483818082a1d3126f096d0284845460114c8880c39d4a5891917fd3d9c0e6b6d9680b4144704
ece25d6ae44045cbce75d88c73c4ff421936b9be309ab6fbc8af54819a8368d38c4eeed6dcbf78e4
81ba996575400a4f80c905ebb60007c695f90dc7095d3dc2730854faf8ddb21a10c5e36ee401d00e
287fde54038e1a6a47d2a25ccc53389508cb5f636b663ae5df9bef45a692cd6a0122dbb56ca9ddaf
96328eed847fb1e56003a7e85d4a236c5f4c860a0ef40681d47c889fc2c6fcd1d80df4052615e54e
db9767330223e349c42bb144c9bc5434bded2222c150107b78ca5d34d6b559e829cd65e58fdf5ede
dc4790d81e2640cef4ac329197ec6f2b161afb62d341bbcd163e7135b8482b01d16a7f6087c1496a
002203dce04b2f9fb075b31b2d3a4f0e2bf5cfdbe94db6943aecd6396f9a13ad591761b8a8425ae8
d816bb1990d5562ae1ef9b2b04c1bc849f6f3a7adc5130ea45e7bcc57e4bdd944b870615e9f7783d
5aeec9bd80e24ee78274b7d11aa53ee91f66397ddcab7d500d7705b485099d0a59e17f39e903fe21
9eded0f3024dadcb70e37c29744376bf84ea312bbb3605072adb081bea2e21e33e2a002736efe5e0
0747c18d7aab3ceb3dae43f579ae43e009f57a793b37fab5d6fe23059417409788f0d552a7009e34
20743ef1dd12d5b94f39720cd35c227b759c806f1c64e44a8f534bedee43d0b8e304e297bc9c5c1e
67910bf530022abcc07eb3ad89038dc6fd908841014a0dca865127dd2f8ba7887a3bda9434c8cfed
ab6243d7f18fe22aa36f7c3e590f8d866ec0e8adf2afe5d23fb7c99830b5936d0c64808ac5e1495a
6c723cdfdf7b13cd78d5bb33a00fb69ee3a146db57f0cd926a0e3325e5179df1fad2abc33a0f7470
8633e63672278062468ce55a153752c97de8a03f65824d53bf44eb77b70c59ff432c88dc4d5a7e80
f0c165ef4b478f0ff722615ef15e5811209d85046ea72a02941ceb52fff95b651cae314fc53ca0f0
5f18e877cb9b52fbb7a4c973062d34816c255237206be4c94031c2761789b0988f93306b72812b4d
d3c6edea18ef800a470f7438baf4896867ff7b5d131206d9f2fd17e0452ad8430791b2eb22bf9989
100b4567739de08cb9f8c1a78e1916a4b3ac6f584327536af728801fa9ad94cd55571b66ec2c8ee5
630f512a274eeb034f521b0ee512143a3a34b0195d4f8c1f3c974464d3c1f6517edcb15f6907be96
5430d683806dce9cc3300ce2d4071eefe4c1ac5a12001cebbaffa303d0bc3614548fdab82bc666d4
71ad6b47a9799cd518554e6a2f12b53fa3949b6d5a59f54581ddda4ecff36bdabcbe4b385eacd954
5d5a064defe639c22cefb2af3f2b89b2166e830bc720da239b1c4ff6a16a7b7549a8369e3d2fc0fe
96ee70b2349326e60d304b71eafb95b854487ff90507f06efe3ed1a45d3ceb2de3e1b37630386743
f4bdd260efff1117767bdb4a39cf49b2ec7b26e3d358fb678877a3fd316436f1a8ada4886ff289f1
73fa65ccb8dea3598d52f2d8b70467b640709e37e582565ac9e3ed2ca39c8fc969e3069326552569
5793ad901f7075b5147b07e6b7a1cf40b5006f5c0780731ff06d9f3c966bb0785911475ea78f0bbe
97354d995e76a077b2cd5e7a14b7acace0ec6faf227914c3d58c10e9bdb2528f49dda9357a01b6e3
2e090232f2eddb9caa2b3c409fd2092ccf9fea9afcaa23f138122ea3dc9d9fed45e6c3bccb6df212
fe57f8ca7e592c3857f8caa8bcd2e7b172bc35f320d90071dbdc0d2c26d2f40530dfe58d9231d766
9057ce75a0b0a2bad7b895adc6156185c8e9831781e41f9befb5c80c222415622887b8dbaa04d845
3716458b2c280cd8ae5fbefe32e80427c659a09628ec3535b89f4a2a4bc0aa034e2852a00be93605
b474b36e27b8eb8f586efd4c89ce2049e60849832ba6972980e86fe36cc652f84ba20bb10538680c
fee4d32a
#END

#BEGIN DEVICE
	@LocalIOMaster, 12, 27
	@RamFS, 1, 1
	@UserLog, 7, 11
	@IntEthernet, 4, 2
	@DMLogger, 5, 10
	@IntModTCPClient, 9, 14, 1000, 2, 60
	@IntEIPClient, 22, 31, 1000, 2, 60
	@IntEthDMPPClient, 23, 32, 50, 250, 2
	@IntSerial, 10, 15
	@IntProcSim, 11, 26
	@SDCardFS, 25, 1
#END

#BEGIN MEM_CONFIG
	X	BIT	decimal	2048	-1
	Y	BIT	decimal	2048	-1
	WX	SWORD	decimal	256	-1
	WY	SWORD	decimal	256	-1
	C	BIT	decimal	2048
	V	UWORD	decimal	4096
	N	SWORD	decimal	4096
	D	SDWORD	decimal	4096
	R	REAL	decimal	4096
	T	TIMER	decimal	256
	CT	COUNTER	decimal	256
	SS	STRING	decimal	128
	SL	STRING	decimal	64
	UDT	DATETIME	decimal	32
	PL	UWORD	decimal	256
	DLX	BIT	octal	01000	-1
	DLY	BIT	octal	01000	-1
	DLC	BIT	octal	01000
	DLV	UWORD	octal	04000
	MI	BIT	decimal	1024
	MC	BIT	decimal	1024
	MIR	SWORD	decimal	2048
	MHR	SWORD	decimal	2048
	RX	REAL	decimal	256	-1
	RY	REAL	decimal	256	-1
	STKC	BIT	decimal	256
	STKD	SWORD	decimal	64
	STKT	TIMER	decimal	64
	MSG	STRING		0
	ERR	STRING		0
	SysName	STRING		0
	SysDesc	STRING		0
	SerialNum	STRING		0
	PartNum	STRING		0
	NewStker	PROGRAM		0	-1
	TestNewStker	PROGRAM		0	-1
	Stkr_SetState	<Virtual>		0
	Stkr_DetectState	<Virtual>		0
	stkr_CycleState	TASK		0	-1
	tst_mock_stkr	<Virtual>		0
	mock_stkrStart	TASK		0	-1
	stkr_BufferX	TASK		0	-1
	mock_stkrCycle	TASK		0	-1
	stkr_BufferY	TASK		0	-1
	Run	PROGRAM		0	-1
	Glue	PROGRAM		0	-1
	tst_stkBufferY	TASK		0	-1
	TestTimer	PROGRAM		0	-1
#END

// Beginning of Code Block Stkr_SetState
$LGCMOD	Stkr_SetState

// Rung Stkr_SetState#1
// Offset 0
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set Stacker States<br>"
"#########################################<br> <br>Set Rest "
"State"
#END

STRE	STKD43	0
SET	STKC10
RST	STKC11
RST	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#2
// Offset 9
#BEGIN FMT_COMMENT 
"Set Ejection / Compression  State"
#END

STRE	STKD43	1
RST	STKC10
SET	STKC11
SET	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#3
// Offset 18
#BEGIN FMT_COMMENT 
"Set Transfer State"
#END

STRE	STKD43	2
RST	STKC10
RST	STKC11
SET	STKC12
SET	STKC13
RST	STKC14

// Rung Stkr_SetState#4
// Offset 27
#BEGIN FMT_COMMENT 
"Set Load State"
#END

STRE	STKD43	3
SET	STKC10
RST	STKC11
RST	STKC12
SET	STKC13
SET	STKC14

// Rung Stkr_SetState#5
// Offset 36
NOP

// Rung Stkr_SetState#6
// Offset 37
NOP

// Rung Stkr_SetState#7
// Offset 38
RET

// End of Code Block Stkr_SetState
$LGCEND	Stkr_SetState

// Beginning of Code Block Stkr_DetectState
$LGCMOD	Stkr_DetectState

// Rung Stkr_DetectState#1
// Offset 0
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Operational States #######################<br>"
"#########################################<br> <br>Detect "
"States<br>#########################################<br> <br>"
"Trasition State"
#END

STR	ST1
MATH	STKD42	"-1"

// Rung Stkr_DetectState#2
// Offset 8
#BEGIN FMT_COMMENT 
" Reset State"
#END

STR	X18
ANDN	X19
AND	X21
AND	X20
AND	X25
AND	X27
MATH	STKD42	"0"

// Rung Stkr_DetectState#3
// Offset 20
#BEGIN FMT_COMMENT 
"Ejection / Compression State"
#END

STRN	STKC0
AND	STKC1
AND	STKC2
AND	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"1"

// Rung Stkr_DetectState#4
// Offset 32
#BEGIN FMT_COMMENT 
"Transfer State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"2"

// Rung Stkr_DetectState#5
// Offset 44
#BEGIN FMT_COMMENT 
"Load State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
ANDN	STKC4
ANDN	STKC5
MATH	STKD42	"3"

// Rung Stkr_DetectState#6
// Offset 56
NOP

// Rung Stkr_DetectState#7
// Offset 57
NOP

// Rung Stkr_DetectState#8
// Offset 58
NOP

// Rung Stkr_DetectState#9
// Offset 59
RET

// End of Code Block Stkr_DetectState
$LGCEND	Stkr_DetectState

// Beginning of Code Block tst_mock_stkr
$LGCMOD	tst_mock_stkr

// Rung tst_mock_stkr#1
// Offset 0
#BEGIN FMT_COMMENT 
"##################################################<br>"
"##  MOCKS  #######################################<br>"
"##################################################<br> "
"<br>Mock Stacker Operation Reset State"
#END

STRE	D50	0
SET	X18
RST	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#2
// Offset 10
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Ejection / Compression "
#END

STRE	D50	1
RST	X18
SET	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#3
// Offset 20
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Transfer State"
#END

STRE	D50	2
SET	X18
RST	X19
RST	X21
RST	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#4
// Offset 30
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Load State"
#END

STRE	D50	3
SET	X18
RST	X19
RST	X21
RST	X20
RST	X25
RST	X27

// Rung tst_mock_stkr#5
// Offset 40
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Broken State"
#END

STRE	D50	5
SET	X18
SET	X19
SET	X21
SET	X20
SET	X25
SET	X27

// Rung tst_mock_stkr#6
// Offset 50
NOP

// Rung tst_mock_stkr#7
// Offset 51
RET

// End of Code Block tst_mock_stkr
$LGCEND	tst_mock_stkr

// Beginning of Code Block $Main
$PRGRM	$Main

// Rung $Main#1
// Offset 0
STR	C200
DUPBOOL
ANDPDPF
RUN	NewStker
POPBOOL
NOT
HALT	NewStker
OUT	C700

// Rung $Main#2
// Offset 9
STR	C201
DUPBOOL
ANDPDPF
RUN	Glue
POPBOOL
NOT
HALT	Glue

// Rung $Main#3
// Offset 17
STR	C203
DUPBOOL
ANDPDPF
RUN	TestNewStker
POPBOOL
NOT
HALT	TestNewStker

// Rung $Main#4
// Offset 25
STR	C204
ENTASK	tst_stkBufferY	0x0	0	0x1
NOT
HALT	tst_stkBufferY

// Rung $Main#5
// Offset 32
STR	C202
RUN	TestTimer
NOT
HALT	TestTimer

// End of Code Block $Main
$PGMEND	$Main

// Beginning of Code Block NewStker
$PRGRM	NewStker

// Rung NewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"#########################################<br>"
"##  RUN STATES  ##########################<br>#########################################"
#END

NOP

// Rung NewStker#2
// Offset 1
#BEGIN FMT_COMMENT 
"Begin Buffering Air Cylinder Outputs"
#END

STR	ST1
ENTASK	stkr_BufferY	0x0	0	0x1

// Rung NewStker#3
// Offset 6
#BEGIN FMT_COMMENT 
"Begin Buffering Eye inputs"
#END

STR	ST1
ENTASK	stkr_BufferX	0x0	0	0x1

// Rung NewStker#4
// Offset 11
#BEGIN FMT_COMMENT 
"#################################################<br>"
"## Error handling ###################################<br>"
"#################################################<br> "
#END

STR	X8
TIMEDOUT	1000	STKC30	0x1

// Rung NewStker#5
// Offset 16
#BEGIN FMT_COMMENT 
"Machine Pre-Run Error"
#END

STRN	X32
ORN	X1
ORN	X2
STR	Y0
ANDN	STKC30
ORSTR
OUT	STKC120
OUT	Y0

// Rung NewStker#6
// Offset 24
#BEGIN FMT_COMMENT 
"Machine Runtime Error"
#END

STR	STKC122
OR	STKC123
OUT	STKC121
OUT	Y2

// Rung NewStker#7
// Offset 28
STR	STKC30
ANDE	STKD42	0
RST	STKC122
RST	STKC123

// Rung NewStker#8
// Offset 35
STR	STKC30
ANDN	STKC120
ANDN	X16
ANDNE	STKD43	0
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"

// Rung NewStker#9
// Offset 51
#BEGIN FMT_COMMENT 
"#################################################<br>"
"## Start up ########################################<br>"
"#################################################<br> "
"<br>Pre-Run Setup"
#END

STRN	STKC120
ANDN	STKC121
OUT	Y4

// Rung NewStker#10
// Offset 54
#BEGIN FMT_COMMENT 
"Machine On State"
#END

STRN	STKC120
ANDN	STKC121
AND	X16
ANDN	STKC30
STR	STKC100
STRE	STKD42	0
ANDE	STKD43	0
ORSTR
ANDSTR
OUT	STKC100
OUT	Y17

// Rung NewStker#11
// Offset 71
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set States<br>#########################################<br>"
" <br>Detect State"
#END

STR	ST1
CALL	Stkr_DetectState	0x1	DST511	"3"	"3"

// Rung NewStker#12
// Offset 79
STR	STKC100
ANDN	STKC31
ENTASK	stkr_CycleState	0x0	0	0x1

// Rung NewStker#13
// Offset 85
STRN	STKC100
OR	STKC31
HALT	stkr_CycleState

// End of Code Block NewStker
$PGMEND	NewStker

// Beginning of Code Block stkr_CycleState
$TSK	stkr_CycleState

// Rung stkr_CycleState#1
// Offset 0
#BEGIN FMT_COMMENT 
"Reset variables for first cycle"
#END

STRPD	ST1
RST	STKC40
RST	STKC41
MATH	STKD45	"0"
MATH	STKD40	"0"
MATH	STKD41	"0"
MATH	D2	"0"
MATH	STKD43	"0"

// Rung stkr_CycleState#2
// Offset 34
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Transition States #########################<br>"
"#########################################<br> <br>Cycle "
"States<br>#########################################<br> <br>"
" <br>    1. Set a bit for every latch cam cycle.  If this "
"bit is not <br>        reset by the time the next cam cycle "
"comes around<br>"
"        it will thorw a Cam Latch Missed error (our cycle "
"is taking too long)<br>        "
#END

STRPD	X17
SET	STKC43
AND	STKC43
SET	STKC123
RST	STKC43

// Rung stkr_CycleState#3
// Offset 40
#BEGIN FMT_COMMENT 
"    2. Determine if stacker should transition state.<br>"
"        * If stacker is in Reset State only cycle if<br>"
"           the latch cam is detected.<br>"
"        * If the cycle is not between state and not "
"<br>           in the reset state.<br>"
"        * aditionally the timers must not have started "
"<br>           yet (its the first scan), or the lockout "
"timer <br>           for the current Cycle State must be "
"expired."
#END

STRE	STKD42	STKD43
ANDGT	STKD42	0
AND	STKT40.Done
STRE	STKD42	0
AND	X17
STR	STKT40.Done
ORN	STKC40
ANDSTR
ORSTR
ANDNE	STKD42	-1
SET	STKC41
SET	STKC40

// Rung stkr_CycleState#4
// Offset 64
#BEGIN FMT_COMMENT 
"    3.  Get variables for state transition<br>"
"        * Each Cycle State as three variables associated "
"<br>           with it:<br>"
"            - Stacker Operation Next Cycle State:<br>"
"                    the next state to cycle to.<br>"
"            - Stacker Operation Lockout ms<br>"
"                    time after transition before a "
"transition <br>"
"                    can be considered again.  Minimum "
"<br>                    transition time.<br>"
"            - Stacker Operation Timout ms<br>"
"                    time after transition before an error "
"is<br>                    thrown.  Maximum transition "
"time.<br>         * Note: Transitioning from Reset State to "
"Ejection State<br>"
"            must reset the Latch Cam Open bit or it is "
"assumed<br>            we missed the cycle and a Missed "
"Latch Cam Cycle <br>            error will be thrown at the "
"end.<br>         * Note: There is no way to detect the "
"trasition between            <br>            Ejection State "
"and Compression State, so we must <br>            also test "
"those states agains the Stacker Operation <br>            "
"State Set to determine the expected state."
#END

STR	STKC41
DUPBOOL
ANDE	STKD42	0
MATH	STKD45	"2"
MATH	STKD40	"1500"
MATH	STKD41	"2000"
RST	STKC43
POPBOOL
DUPBOOL
ANDE	STKD42	1
ANDE	STKD43	1
AND	ST2
MATH	STKD45	"2"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
DUPBOOL
ANDE	STKD42	1
ANDE	STKD43	2
MATH	STKD45	"3"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
DUPBOOL
ANDE	STKD42	2
MATH	STKD45	"4"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
ANDE	STKD42	3
MATH	STKD45	"0"
MATH	STKD40	"1000"
MATH	STKD41	"5000"

// Rung stkr_CycleState#5
// Offset 193
#BEGIN FMT_COMMENT 
"    4. Set the new Cycle State"
#END

STR	STKC41
CALL	Stkr_SetState	0x1	DST511	"3 STKD45 STKD43 1"	"3"
RST	STKC41

// Rung stkr_CycleState#6
// Offset 204
#BEGIN FMT_COMMENT 
"    5. Start lockout time for transition<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection.<br>"
"        * Transitioning is not allowed while lockout<br>"
"           timer is powered and != Done."
#END

STR	STKC40
ANDGT	STKD40	0
STRPD	STKC41
TMRA	STKT40	STKD40

// Rung stkr_CycleState#7
// Offset 213
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Error Trapping ###########################<br>"
"#########################################<br> <br>    6. "
"Test for timeout on state transition<br>"
"        * If the machine takes too long between transitions "
"it is <br>          considered in a broken state.<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection."
#END

STR	STKC40
ANDGT	STKD41	0
STRPD	STKC41
TMRA	STKT41	STKD41

// Rung stkr_CycleState#8
// Offset 222
STR	STKC40
AND	STKT41.Done
ANDGT	STKD41	0
SET	STKC122

// End of Code Block stkr_CycleState
$TSKEND	stkr_CycleState

// Beginning of Code Block stkr_BufferX
$TSK	stkr_BufferX

// Rung stkr_BufferX#1
// Offset 0
STR	X18
ONDTMR	STKT0	STKD0	STKC0

// Rung stkr_BufferX#2
// Offset 4
STR	X19
ONDTMR	STKT1	STKD1	STKC1

// Rung stkr_BufferX#3
// Offset 8
STR	X21
ONDTMR	STKT2	STKD2	STKC2

// Rung stkr_BufferX#4
// Offset 12
STR	X20
ONDTMR	STKT3	STKD3	STKC3

// Rung stkr_BufferX#5
// Offset 16
STR	X25
ONDTMR	STKT4	STKD4	STKC4

// Rung stkr_BufferX#6
// Offset 20
STR	X27
ONDTMR	STKT5	STKD5	STKC5

// End of Code Block stkr_BufferX
$TSKEND	stkr_BufferX

// Beginning of Code Block stkr_BufferY
$TSK	stkr_BufferY

// Rung stkr_BufferY#1
// Offset 0
STR	STKC10
ONDTMR	STKT15	STKD15	STKC15
ANDNDPF
OFFDTMR	STKT16	STKD16	STKC16

// Rung stkr_BufferY#2
// Offset 8
STR	STKC11
ONDTMR	STKT17	STKD17	STKC17
ANDNDPF
OFFDTMR	STKT18	STKD18	STKC18

// Rung stkr_BufferY#3
// Offset 16
STR	STKC12
ONDTMR	STKT19	STKD19	STKC19
ANDNDPF
OFFDTMR	STKT20	STKD20	STKC20

// Rung stkr_BufferY#4
// Offset 24
STR	STKC13
ONDTMR	STKT21	STKD21	STKC21
ANDNDPF
OFFDTMR	STKT22	STKD22	STKC22

// Rung stkr_BufferY#5
// Offset 32
STR	STKC14
ONDTMR	STKT23	STKD23	STKC23
ANDNDPF
OFFDTMR	STKT24	STKD24	STKC24

// Rung stkr_BufferY#6
// Offset 40
STR	STKC15
OR	STKC16
OUT	Y12

// Rung stkr_BufferY#7
// Offset 43
STR	STKC17
OR	STKC18
OUT	Y11

// Rung stkr_BufferY#8
// Offset 46
STR	STKC19
OR	STKC20
OUT	Y10

// Rung stkr_BufferY#9
// Offset 49
STR	STKC21
OR	STKC22
OUT	Y9

// Rung stkr_BufferY#10
// Offset 52
STR	STKC23
OR	STKC24
OUT	Y5

// Rung stkr_BufferY#11
// Offset 55
NOP

// End of Code Block stkr_BufferY
$TSKEND	stkr_BufferY

// Beginning of Code Block TestNewStker
$PRGRM	TestNewStker

// Rung TestNewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"##################################################<br>"
"## Tests  ##########################################<br>"
"##################################################<br> "
"<br>##################################################<br> "
"<br>Initialize Variables<br>##################################################"
#END

STRPD	ST1
RSTR	C400	C449
RSTR	C600	C649
SET	STKC31

// Rung TestNewStker#2
// Offset 7
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Set Up Mocks<br>"
"#################################################<br> "
"<br>    Mock Stacker Start"
#END

STR	C408
ENTASK	mock_stkrStart	0x0	0	0x1
NOT
HALT	mock_stkrStart

// Rung TestNewStker#3
// Offset 14
STR	STKC100
RST	C408

// Rung TestNewStker#4
// Offset 16
#BEGIN FMT_COMMENT 
"    Mock Stacker Cycle"
#END

STR	C406
ENTASK	mock_stkrCycle	0x0	0	0x1
NOT
HALT	mock_stkrCycle

// Rung TestNewStker#5
// Offset 23
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Run Tests<br>"
"#################################################<br> "
"<br>    1. Mock Stacker Reset State"
#END

STRPD	ST1
ANDN	C600
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"

// Rung TestNewStker#6
// Offset 35
#BEGIN FMT_COMMENT 
"    2. Mock Turn on Stacker"
#END

STRPD	ST1
ANDN	C600
SET	C408

// Rung TestNewStker#7
// Offset 39
STR	STKC100
SET	C600

// Rung TestNewStker#8
// Offset 41
NOP

// Rung TestNewStker#9
// Offset 42
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Pre-Run Error<br>"
"#################################################<br> "
"<br>    2. Make sure Run State stopped and error was raised "
"before restarting<br>"
"        * Mock restart stacker already clears errors."
#END

STR	C600
ANDN	C601
ANDN	STKC100
AND	STKC120
SET	C408

// Rung TestNewStker#10
// Offset 47
#BEGIN FMT_COMMENT 
"    1. Mock Pre-run error<br>"
"        * make sure stacker is running for this test"
#END

STR	C600
ANDN	C601
ANDN	C409
AND	STKC100
RST	X1
SET	C409

// Rung TestNewStker#11
// Offset 53
#BEGIN FMT_COMMENT 
"     3. Confirm error cleared and stacker restarted"
#END

STR	C600
ANDN	C601
AND	X1
AND	C409
AND	STKC100
SET	C601
RST	C409

// Rung TestNewStker#12
// Offset 60
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Run-Time Error<br>"
"#################################################<br> "
"<br>    2. Clear error and attemp restart, which should "
"fail due<br>"
"         the stacker not being a Reset State.  Use a timer "
"to<br>         confirm the Mock Start Up had time to try "
"and start."
#END

STR	C601
ANDN	C602
AND	C409
RST	STKC123
ANDN	STKC123
SET	C408
TMR	T200	1000

// Rung TestNewStker#13
// Offset 68
#BEGIN FMT_COMMENT 
"    1. Set cycle state to something other than reset<br>"
"        so stacker error can't be cleared.  Then mock error."
#END

STR	C601
ANDN	C602
DUPBOOL
ANDPDPF
ANDNE	D50	3
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
ANDE	D50	3
SET	STKC123
SET	C409

// Rung TestNewStker#14
// Offset 92
#BEGIN FMT_COMMENT 
"    3. If the timer experied and the stacker still hasn't "
"started<br>        we can be confident it won't start in "
"when the cycle is<br>        not in a Reset State."
#END

STR	C601
ANDN	C602
AND	T200.Done
ANDN	STKC100
SET	C410

// Rung TestNewStker#15
// Offset 97
#BEGIN FMT_COMMENT 
"    5. Confirm the Stacker Cycle is now in a Reset State "
"and <br>        attempt to start again."
#END

STR	C601
ANDN	C602
AND	C410
ANDE	D50	0
SET	C408

// Rung TestNewStker#16
// Offset 105
#BEGIN FMT_COMMENT 
"    4. Mock setting the Cycle State to the Reset State.<br>"
"        Stop the Mock Restart from running."
#END

STR	C601
ANDN	C602
AND	C410
ANDNE	D50	0
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
RST	C408

// Rung TestNewStker#17
// Offset 122
#BEGIN FMT_COMMENT 
"    6. Confirm start was successful this time."
#END

STR	C601
ANDN	C602
ANDN	STKC123
AND	C410
AND	STKC100
SET	C602
RSTR	C409	C410

// Rung TestNewStker#18
// Offset 130
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Detect States Test<br>"
"#################################################<br> "
"<br>     1. Mock each Cycle State one by one."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	tst_mock_stkr	0x1	DST511	"3 1 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	tst_mock_stkr	0x1	DST511	"3 2 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
AND	C412
ANDN	C413
CALL	tst_mock_stkr	0x1	DST511	"3 5 D50 1"	"3"

// Rung TestNewStker#19
// Offset 194
#BEGIN FMT_COMMENT 
"    2. Test every scan to confirm the Cycle State was "
"changed to the <br>         next state."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
ANDE	D12	0
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
ANDE	D12	1
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
ANDE	D12	2
SET	C411
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
ANDE	D12	3
SET	C412
POPBOOL
AND	C412
ANDN	C413
ANDE	D12	-1
SET	C413

// Rung TestNewStker#20
// Offset 238
#BEGIN FMT_COMMENT 
"    3. Detect the state so it can be tested next scan."
#END

STR	C602
ANDN	C603
CALL	Stkr_DetectState	0x1	DST511	"3"	"3 STKD42 D12 1"

// Rung TestNewStker#21
// Offset 249
#BEGIN FMT_COMMENT 
"    4. Confirm all states have been detected once."
#END

STR	C602
ANDN	C603
AND	C409
AND	C410
AND	C411
AND	C412
AND	C413
SET	C603
RSTR	C409	C414

// Rung TestNewStker#22
// Offset 259
NOP

// Rung TestNewStker#23
// Offset 260
NOP

// Rung TestNewStker#24
// Offset 261
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Set States Test<br>"
"#################################################<br> "
"<br>    1. Set each Cycle State one by one after each state "
"has been<br>        confirmed."
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
CALL	Stkr_SetState	0x0	DST511	"3 0 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	Stkr_SetState	0x0	DST511	"3 1 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	Stkr_SetState	0x0	DST511	"3 2 STKD43 1"	"3"
POPBOOL
AND	C411
ANDN	C412
CALL	Stkr_SetState	0x0	DST511	"3 3 STKD43 1"	"3"

// Rung TestNewStker#25
// Offset 316
#BEGIN FMT_COMMENT 
"    2. Test each cycle to see a state has been "
"successfully set"
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
AND	Y12
ANDN	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
ANDN	Y12
AND	Y11
AND	Y10
ANDN	Y9
ANDN	Y5
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
AND	Y12
ANDN	Y11
AND	Y10
AND	Y9
ANDN	Y5
SET	C411
POPBOOL
AND	C411
ANDN	C412
AND	Y12
ANDN	Y11
ANDN	Y10
AND	Y9
AND	Y5
SET	C412

// Rung TestNewStker#26
// Offset 355
#BEGIN FMT_COMMENT 
"    3. Confirm all states have been set at least once."
#END

STR	C603
ANDN	C604
AND	C409
AND	C410
AND	C411
AND	C412
SET	C604
RSTR	C409	C413

// Rung TestNewStker#27
// Offset 364
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Cycle State<br>"
"#################################################<br> <br> "
#END

NOP

// Rung TestNewStker#28
// Offset 365
#BEGIN FMT_COMMENT 
"    2. Delay starting the Cycle Mock to test that the "
"Cycle Task<br>"
"        can run without the machine on.  In production the "
"Task<br>        will always turn on before the machine and "
"will wait for the first <br>        Latch Cam Cycle to "
"trigger its logic."
#END

STR	C604
ANDN	C605
ANDN	STKC31
DUPBOOL
AND	ST1
TMR	T201	2000
POPBOOL
DUPBOOL
AND	ST1
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
AND	T201.Done
AND	ST1
SET	C406

// Rung TestNewStker#29
// Offset 398
#BEGIN FMT_COMMENT 
"    1. Turn on the stkr_CycleState state task for testing"
#END

STR	C604
ANDN	C605
AND	STKC31
RST	STKC31

// Rung TestNewStker#30
// Offset 402
STR	C604
ANDN	C605
MATH	D6	"(CT0.Acc == CT1.Acc) && (CT0.Acc == CT2.Acc) && (CT0.Acc == CT3.Acc) && (CT0.Acc == CT4.Acc)"

// Rung TestNewStker#31
// Offset 424
#BEGIN FMT_COMMENT 
" "
#END

STR	C604
ANDN	C605
AND	STKC100
ANDE	CT0.Acc	4
ANDE	D6	1
SET	C605
RST	C420
RST	C406

// Rung TestNewStker#32
// Offset 438
STR	ST1
STR	ST0
CNT	CT6	D80

// End of Code Block TestNewStker
$PGMEND	TestNewStker

// Beginning of Code Block mock_stkrStart
$TSK	mock_stkrStart

// Rung mock_stkrStart#1
// Offset 0
STR	C407
RST	X8

// Rung mock_stkrStart#2
// Offset 2
#BEGIN FMT_COMMENT 
"Turn On Stacker"
#END

STRPD	ST1
SET	X1
SET	X32
SET	X2
SET	X8
OUT	C407

// Rung mock_stkrStart#3
// Offset 9
STRN	X8
ANDE	STKD43	0
SET	X16

// Rung mock_stkrStart#4
// Offset 15
NOP

// End of Code Block mock_stkrStart
$TSKEND	mock_stkrStart

// Beginning of Code Block mock_stkrCycle
$TSK	mock_stkrCycle

// Rung mock_stkrCycle#1
// Offset 0
#BEGIN FMT_COMMENT 
"1. Initialize stacker Cycle State to the Reset State"
#END

STRPD	ST1
DUPBOOL
ANDNE	STKD42	0
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
ANDNE	STKD43	0
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
POPBOOL
AND	ST1
MATH	D27	"6000"
RST	C427

// Rung mock_stkrCycle#2
// Offset 42
#BEGIN FMT_COMMENT 
"2. Mock the cam cycling"
#END

STR	ST1
FLASHER	100	D27	C420

// Rung mock_stkrCycle#3
// Offset 47
STR	ST1
DUPBOOL
AND	C420
SET	X17
POPBOOL
ANDN	C420
RST	X17

// Rung mock_stkrCycle#4
// Offset 54
#BEGIN FMT_COMMENT 
"3. Mock the input values for each Cycle State after the "
"<br>        outputs reach the corrosponding Cycle State."
#END

STR	ST1
DUPBOOL
AND	Y12
ANDN	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 0 D50 1"	"3"
OUT	C421
POPBOOL
DUPBOOL
AND	Y12
AND	Y11
ANDN	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 1 D50 1"	"3"
OUT	C422
POPBOOL
DUPBOOL
ANDN	Y12
AND	Y11
AND	Y10
ANDN	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 2 D50 1"	"3"
OUT	C423
POPBOOL
DUPBOOL
ANDN	Y12
ANDN	Y11
AND	Y10
AND	Y9
ANDN	Y5
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
OUT	C424
POPBOOL
AND	Y12
ANDN	Y11
ANDN	Y10
AND	Y9
AND	Y5
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 4 D50 1"	"3"
OUT	C425

// Rung mock_stkrCycle#5
// Offset 147
#BEGIN FMT_COMMENT 
"    4. Count each new state set for testing.<br>"
"        <br>        * Count Reset State Set"
#END

STR	C421
STRPD	ST1
CNT	CT0	D20

// Rung mock_stkrCycle#6
// Offset 152
#BEGIN FMT_COMMENT 
"        * Count Ejection State Set"
#END

STR	C422
STRPD	ST1
CNT	CT1	D21

// Rung mock_stkrCycle#7
// Offset 157
#BEGIN FMT_COMMENT 
"        * Count Compression State Set"
#END

STR	C423
STRPD	ST1
CNT	CT2	D22

// Rung mock_stkrCycle#8
// Offset 162
#BEGIN FMT_COMMENT 
"        * Count Transition State Set"
#END

STR	C424
STRPD	ST1
CNT	CT3	D23

// Rung mock_stkrCycle#9
// Offset 167
#BEGIN FMT_COMMENT 
"        * Count Load State Set"
#END

STR	C425
STRPD	ST1
CNT	CT4	D24

// Rung mock_stkrCycle#10
// Offset 172
#BEGIN FMT_COMMENT 
"    5. Count each transition for testing."
#END

STR	C413
STRPD	ST1
CNT	CT5	D25

// Rung mock_stkrCycle#11
// Offset 177
#BEGIN FMT_COMMENT 
"    6. Random Transition Offset"
#END

STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
ANDGT	STKD40	0
ANDPDPF
MATH	D26	"(((STKD41 - 5) - STKD40) * RANDREAL()) + STKD40"
SET	C427

// Rung mock_stkrCycle#12
// Offset 202
STR	ST1
STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
TMRA	T202	D26

// End of Code Block mock_stkrCycle
$TSKEND	mock_stkrCycle

// Beginning of Code Block Run
$PRGRM	Run

// Rung Run#1
// Offset 0
#BEGIN FMT_COMMENT 
"#############################################<br>"
"## Buffers #####################################<br>"
"#############################################<br> <br>Run"
#END

STR	X0
ANDN	C20
STR	C10
ANDN	C15
AND	C20
ORSTR
ONDTMR	T3	D0	C1
OUT	C10

// Rung Run#2
// Offset 10
#BEGIN FMT_COMMENT 
"Jog"
#END

STR	X1
ANDN	C20
STR	C11
ANDN	C15
AND	C20
ORSTR
ONDTMR	T4	D1	C2
OUT	C11

// Rung Run#3
// Offset 20
#BEGIN FMT_COMMENT 
"Thread"
#END

STR	X2
ANDN	C20
STR	C12
ANDN	C15
AND	C20
ORSTR
ONDTMR	T5	D3	C3
OUT	C12

// Rung Run#4
// Offset 30
#BEGIN FMT_COMMENT 
"Stop Buffer"
#END

STRN	X3
NOT
OUT	C15

// Rung Run#5
// Offset 33
#BEGIN FMT_COMMENT 
"Any running signal / Bell"
#END

STR	C10
OR	C11
OR	C12
OUT	C20
ANDPDPF
OUT	Y0

// End of Code Block Run
$PGMEND	Run

// Beginning of Code Block Glue
$PRGRM	Glue

// Rung Glue#1
// Offset 0
STR	X58
ANDN	X59
OUT	Y54

// Rung Glue#2
// Offset 3
STRN	X58
AND	X59
AND	STKC42
AND	X62
OUT	Y55

// Rung Glue#3
// Offset 8
STR	Y54
OR	Y55
AND	ST2
OUT	Y69

// Rung Glue#4
// Offset 12
STRN	X16
OFFDTMR	T0	1400	C0

// Rung Glue#5
// Offset 16
STR	X16
AND	STKC42
OR	Y72
ANDN	T0.Done
AND	ST2
OUT	Y72

// Rung Glue#6
// Offset 22
NOP

// Rung Glue#7
// Offset 23
NOP

// Rung Glue#8
// Offset 24
NOP

// End of Code Block Glue
$PGMEND	Glue

// Beginning of Code Block tst_stkBufferY
$TSK	tst_stkBufferY

// Rung tst_stkBufferY#1
// Offset 0
STRPD	ST1
RSTR	C409	C413
RSTR	STKC15	STKC24
RSTR	C610	C615

// Rung tst_stkBufferY#2
// Offset 8
#BEGIN FMT_COMMENT 
"Make sure output is off"
#END

STR	C409
ANDN	C414
TMR	T1	D30
TMR	T2	D31
SET	C410

// Rung tst_stkBufferY#3
// Offset 15
STR	C413
STR	ST2
CNT	CT7	D0

// Rung tst_stkBufferY#4
// Offset 19
#BEGIN FMT_COMMENT 
"#####################################<br>"
"## Run Test ###########################<br>#####################################<br>"
" <br> <br> <br>Test Vertical Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STRN	C610
SET	STKC10
ANDPDPF
SET	C409
MATH	D30	"STKD15 + 500"
MATH	D31	"STKD16 + 500"

// Rung tst_stkBufferY#5
// Offset 39
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STRN	C610
AND	C410
AND	T1.Done
RST	STKC10

// Rung tst_stkBufferY#6
// Offset 43
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STRN	C610
STRPD	STKC10
ORND	STKC10
ANDSTR
OUT	C413

// Rung tst_stkBufferY#7
// Offset 50
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STRN	C610
AND	C410
AND	STKC10
STRN	STKT15.Done
AND	Y12
AND	ST1
STRN	STKT15.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT15.Done
ANDN	Y12
AND	ST1
ORSTR
STR	STKT16.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#8
// Offset 69
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STRN	C610
AND	C410
ANDN	STKC10
STRN	STKT16.Done
ANDN	Y12
AND	ST1
STR	STKT16.Timing
ANDN	Y12
AND	ST1
ORSTR
STR	STKT16.Done
AND	Y12
ANDN	C413
AND	ST1
ORSTR
STR	STKT15.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#9
// Offset 90
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STRN	C610
AND	C410
ANDN	STKC10
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C610
RSTR	C409	C413
OUT	C414

// Rung tst_stkBufferY#10
// Offset 100
#BEGIN FMT_COMMENT 
"Test Ejection Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C610
ANDN	C611
SET	STKC11
ANDPDPF
SET	C409
MATH	D30	"STKD17 + 500"
MATH	D31	"STKD18 + 500"

// Rung tst_stkBufferY#11
// Offset 121
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C610
ANDN	C611
AND	C410
AND	T1.Done
RST	STKC11

// Rung tst_stkBufferY#12
// Offset 126
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C610
ANDN	C611
STRPD	STKC11
ORND	STKC11
ANDSTR
OUT	C413

// Rung tst_stkBufferY#13
// Offset 134
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C610
ANDN	C611
AND	C410
AND	STKC11
STRN	STKT17.Done
AND	Y11
AND	ST1
STRN	STKT17.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT17.Done
ANDN	Y11
AND	ST1
ORSTR
STR	STKT18.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#14
// Offset 154
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C610
ANDN	C611
AND	C410
ANDN	STKC11
STRN	STKT18.Done
ANDN	Y11
AND	ST1
STR	STKT18.Timing
ANDN	Y11
AND	ST1
ORSTR
STR	STKT18.Done
AND	Y11
ANDN	C413
AND	ST1
ORSTR
STR	STKT17.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#15
// Offset 176
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C610
ANDN	C611
AND	C410
ANDN	STKC11
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C611
RSTR	C409	C412

// Rung tst_stkBufferY#16
// Offset 186
#BEGIN FMT_COMMENT 
"Test Compression Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C611
ANDN	C612
SET	STKC12
ANDPDPF
SET	C409
MATH	D30	"STKD19 + 500"
MATH	D31	"STKD20 + 500"

// Rung tst_stkBufferY#17
// Offset 207
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C611
ANDN	C612
AND	C410
AND	T1.Done
RST	STKC12

// Rung tst_stkBufferY#18
// Offset 212
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C611
ANDN	C612
STRPD	STKC12
ORND	STKC12
ANDSTR
OUT	C413

// Rung tst_stkBufferY#19
// Offset 220
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C611
ANDN	C612
AND	C410
AND	STKC12
STRN	STKT19.Done
AND	Y10
AND	ST1
STRN	STKT19.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT19.Done
ANDN	Y10
AND	ST1
ORSTR
STR	STKT20.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#20
// Offset 240
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C611
ANDN	C612
AND	C410
ANDN	STKC12
STRN	STKT20.Done
ANDN	Y10
AND	ST1
STR	STKT20.Timing
ANDN	Y10
AND	ST1
ORSTR
STR	STKT20.Done
AND	Y10
ANDN	C413
AND	ST1
ORSTR
STR	STKT19.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#21
// Offset 262
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C611
ANDN	C612
AND	C410
ANDN	STKC12
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C612
RSTR	C409	C412

// Rung tst_stkBufferY#22
// Offset 272
#BEGIN FMT_COMMENT 
"Test Transfer Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C612
ANDN	C613
SET	STKC13
ANDPDPF
SET	C409
MATH	D30	"STKD21 + 500"
MATH	D31	"STKD22 + 500"

// Rung tst_stkBufferY#23
// Offset 293
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C612
ANDN	C613
AND	C410
AND	T1.Done
RST	STKC13

// Rung tst_stkBufferY#24
// Offset 298
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C612
ANDN	C613
STRPD	STKC13
ORND	STKC13
ANDSTR
OUT	C413

// Rung tst_stkBufferY#25
// Offset 306
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C612
ANDN	C613
AND	C410
AND	STKC13
STRN	STKT21.Done
AND	Y9
AND	ST1
STRN	STKT21.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT21.Done
ANDN	Y9
AND	ST1
ORSTR
STR	STKT22.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#26
// Offset 326
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C612
ANDN	C613
AND	C410
ANDN	STKC13
STRN	STKT22.Done
ANDN	Y9
AND	ST1
STR	STKT22.Timing
ANDN	Y9
AND	ST1
ORSTR
STR	STKT22.Done
AND	Y9
ANDN	C413
AND	ST1
ORSTR
STR	STKT21.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#27
// Offset 348
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C612
ANDN	C613
AND	C410
ANDN	STKC13
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C613
RSTR	C409	C412

// Rung tst_stkBufferY#28
// Offset 358
#BEGIN FMT_COMMENT 
"Test Load Bar Buffer<br>"
"####################################<br>////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////<br>"
" <br>   * Start Timers"
#END

STR	C613
ANDN	C614
SET	STKC14
ANDPDPF
SET	C409
MATH	D30	"STKD23 + 500"
MATH	D31	"STKD24 + 500"

// Rung tst_stkBufferY#29
// Offset 379
#BEGIN FMT_COMMENT 
"Turn off Buffer after test timer has expired<br>"
"   * Test Buffer timer == OnBufferTimer + 500ms"
#END

STR	C613
ANDN	C614
AND	C410
AND	T1.Done
RST	STKC14

// Rung tst_stkBufferY#30
// Offset 384
#BEGIN FMT_COMMENT 
"Flip a bit on for 1 scan everytime the Input Buffer "
"changes<br>    * Some of the tests are sensative to race "
"conditions so<br>"
"       this prevents them from having an inaccurate reading.<br>"
"    * In production nothing should ever read the Buffer "
"timer <br>"
"      outputs except for the Y outputs so these race conditions<br>"
"      should not be a factor in production."
#END

STR	C613
ANDN	C614
STRPD	STKC14
ORND	STKC14
ANDSTR
OUT	C413

// Rung tst_stkBufferY#31
// Offset 392
#BEGIN FMT_COMMENT 
"Test On Buffer against various conditions. <br>    * Set "
"bit to indicate error if any condition is met."
#END

STR	C613
ANDN	C614
AND	C410
AND	STKC14
STRN	STKT23.Done
AND	Y5
AND	ST1
STRN	STKT23.Timing
ANDN	C413
AND	ST1
ORSTR
STR	STKT23.Done
ANDN	Y5
AND	ST1
ORSTR
STR	STKT24.Timing
AND	ST1
ORSTR
ANDSTR
SET	C411

// Rung tst_stkBufferY#32
// Offset 412
#BEGIN FMT_COMMENT 
"Test Off Buffer against various conditions.<br>"
"    * Set bit to indicate error if any condition is met."
#END

STR	C613
ANDN	C614
AND	C410
ANDN	STKC14
STRN	STKT24.Done
ANDN	Y5
AND	ST1
STR	STKT24.Timing
ANDN	Y5
AND	ST1
ORSTR
STR	STKT24.Done
AND	Y5
ANDN	C413
AND	ST1
ORSTR
STR	STKT23.Timing
ANDN	C413
AND	ST1
ORSTR
ANDSTR
SET	C412

// Rung tst_stkBufferY#33
// Offset 434
#BEGIN FMT_COMMENT 
"Mark test successful if output is off, both timers "
"expired, and no errors were thrown"
#END

STR	C613
ANDN	C614
AND	C410
ANDN	STKC14
ANDN	C411
ANDN	C412
AND	T2.Done
SET	C614
RSTR	C409	C412

// Rung tst_stkBufferY#34
// Offset 444
NOP

// End of Code Block tst_stkBufferY
$TSKEND	tst_stkBufferY

// Beginning of Code Block TestTimer
$PRGRM	TestTimer

// Rung TestTimer#1
// Offset 0
NOP

// Rung TestTimer#2
// Offset 1
STRE	SDT0.DayOfWeek	6
MATH	D4	"0"
NOT
MATH	D4	"SDT0.DayOfWeek + 1"

// Rung TestTimer#3
// Offset 20
STRGE	SDT0.DayOfWeek	D8
ANDLE	SDT0.DayOfWeek	D9
ANDLE	SDT0.Hour	D10
ANDLE	SDT0.Minute	D11
STRGE	D4	D8
ANDLE	D4	D9
ORSTR
OUT	C30

// Rung TestTimer#4
// Offset 46
STR	C30
OR	X11
OR	C31
AND	X10
OUT	C31

// Rung TestTimer#5
// Offset 51
STR	C31
ANDN	C34
ANDGE	SDT0.Hour	UDT0.Hour
ANDGE	SDT0.Minute	UDT0.Minute
OUT	C33
SET	C34
ANDNDPF
RST	C31

// Rung TestTimer#6
// Offset 65
STRE	SDT0.Hour	0
ANDE	SDT0.Minute	0
RST	C31

// Rung TestTimer#7
// Offset 74
NOP

// Rung TestTimer#8
// Offset 75
STR	C36
OR	C33
STR	C35
ANDN	C36
ORSTR
OUT	C35

// Rung TestTimer#9
// Offset 81
NOP

// End of Code Block TestTimer
$PGMEND	TestTimer

#BEGIN ELEMENT_DOC
"X1","","","Air SW on Stacker"
"X2","","","Air Pressure OK"
"X8","","","Stacker Reset PB"
"X10","","","Glue Auto Warmup SW"
"X11","","","Manually Prime Auto Warm Glue"
"X16","","","Machine Run Started"
"X17","","","Latch Cam Start Cycle"
"X18","","","Eject In"
"X19","","","Eject Out"
"X20","","","Transfer Operator Side"
"X21","","","Transfer Drive Side"
"X25","","","Operator Side Load In"
"X27","","","Operator Side Load Out"
"X32","","","Guard Door SW"
"X58","","","Tape Glue Manual"
"X59","","","Tape Glue Auto"
"X62","","","Machine In Run"
"Y0","","","Stacker Jam Light"
"Y2","","","Timing Fault Light"
"Y4","","","Gradual Start Valve"
"Y5","","","Operator Side Load Sol"
"Y9","","","Transfer Sol"
"Y10","","","Compression Sol"
"Y11","","","Ejection Sol"
"Y12","","","Vertical Bar Sol"
"Y17","","","Machine Stop Interlock"
"Y54","","","Tape Glue SOL Manual"
"Y55","","","Tape Glue SOL Auto"
"Y69","","","Tape Glue Pump On"
"Y72","","","Tape Power Relay"
"C30","","","Standard Work Week Day"
"C31","","","Arm Auto Warm Glue Lamp"
"C32","","","Auto Warm Glue Armed Lamp"
"C33","","","Auto Heat Glue"
"C34","","","Auto Glue Triggered Today"
"C36","","","Manually Heat Glue"
"C200","","","Enable Stacker Program"
"C201","","","Enable Glue Program"
"C203","","","Enable Stacker Test"
"C400","","","Mock Stacker Operation Pre-Run State"
"C401","","","Mock Stacker Operation Reset State"
"C402","","","Mock Stacker Operation Ejection State"
"C403","","","Mock Stacker Operation Compression State"
"C404","","","Mock Stacker Operation Transfer State"
"C405","","","Mock Stacker Operation Load State"
"C406","","","Mock Stacker Operation Cycle"
"C407","","","Mock Turn On Stacker"
"C408","","","Mock Restart Stacker"
"C600","","","Passed Stacker On Test"
"C601","","","Passed Stacker Pre- Run Error Test"
"C602","","","Passed Stacker Runtime Error Test"
"C603","","","Passed Stacker Detect State Test"
"C604","","","Passed Stacker Set State"
"C605","","","Passed Stacker Set State"
"D30","","","Vertical Bar On Buffer"
"D31","","","Ejection On Buffer"
"D32","","","Compression On Buffer"
"D33","","","Transfer On Buffer"
"D34","","","Load On Buffer"
"D40","","","Vertical Bar Off Buffer"
"D50","","","Stacker Operation Mock State"
"STKC0","","","Eject In Eye Buffer"
"STKC1","","","Eject Out Eye Buffer"
"STKC2","","","Transfer Drive Side Eye Buffer"
"STKC3","","","Transfer Operator Side Eye Buffer"
"STKC4","","","Load In Eye Buffer"
"STKC5","","","Load Out Eye Buffer"
"STKC10","","","Stacker Operation Vertical Bar SOL Buffered"
"STKC11","","","Stacker Operation Ejection SOL Buffered"
"STKC12","","","Stacker Operation Compression SOL Buffered"
"STKC13","","","Stacker Operation Transfer SOL Buffered"
"STKC14","","","Stacker Operation Load SOL Buffered"
"STKC30","","","Stacker Reset Press"
"STKC31","","","Stacker Cycle Disconnect"
"STKC40","","","Begin Timers"
"STKC41","","","Transition State"
"STKC42","","","Stacker Start Up Cycle Delay"
"STKC43","","","Latch Cycle Open"
"STKC100","","","Stacker Run State"
"STKC120","","","Stacker Pre Run Error State"
"STKC121","","","Stacker Run Time Error State"
"STKC122","","","Stacker Operation Transition State Timeout Error"
"STKC123","","","Stacker Operation Missed Cam Latch Cycle Error"
"STKD40","","","Stacker Operation Transition Lock Out ms"
"STKD41","","","Stacker Opertation Transition Time Out ms"
"STKD42","","","Stacker Operation Detected State"
"STKD43","","","Stacker Operation State Set"
"STKD45","","","Stacker Operation Next Cycle State"
#END

