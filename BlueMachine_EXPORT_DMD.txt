// Options: Export entire program; Code Block delimiter instructions;
// Formatted Rung Comments; Element Documentation Database; System Configuration;
// Memory Configuration/Devices with Built-In Types and User Add-Ons;
// use Element names (no NickNames); rung/address annotations;
// <TAB> parameter delimiter; 
// Write/overwrite file C:\Users\jmarshall\source\BlueMachinePLC\BlueMachine_EXPORT_DMD.txt

PLC H2-DM1E

// Do not modify SYS_CONFIG block!
#BEGIN SYS_CONFIG
13354c5e88c42a21a4379508ad0472b823b478323808e561bc0f22337f105c5993d807a02d3f3df7
8e2ee4fca4ac02ca8a14c23b34bb402b3fba3952d66eb7041b21530360fd1fbb1e9eb922711538e2
924024306fbe6d5bd138ead8f450b8ca03fc9c7aacac23083b0a98f65cd681fd1fb14f4f208fb29e
d8642a3edb9027f0c814a64bc8e83bfdc2d14376dcb94f0316c0242b25b68023144eb0d5e0159c09
38eccd605233154a597e60c84b719ae1844ffce74afc8ceb9a4d3ed97439e1d2cc0a261073197bb1
ee9a2fdad1f77ca2d54d0db979d667daee72047f1995b33daa3c48d201b76ded176c8a62f3f3d4cb
263a05114b100f33361f89e29e82f9b4e864a3de6c1163ccd547cfb75e7f64d697e3fc3cb7d147ef
c7ec4b996526047be0b554c3d86b3c190003a6d8175f783a495163904fa5085a08e769316ec4807a
95fd541b29382940375c6ed50653fc91883b91817dd6c27f2ef2d11ae8672cd21e694092ec684f1f
7e425af8a9764b044dd5c52c692b214239b252c683f4fe98d4cacfa2fa42ce6f83331a151b318b06
9365b0dbf9a496cafcf8d8d3dc38181dafb50dc462c3ca6c270416e094424f22e8531407b2b04d3d
92febb952e6053b69608486e3ad1d55a45a0f55d4795a6ab954dfad186c18ad45b38af6425704735
902ac6a1baa62840ab46d3dc017c88b5bef49d2797c9276e24e7dd8d6b9345e20697ea0d5fb53fe0
0ae55ae0d9d9602ed18fb4c9721873b1f3d3de45e56dd4671b9ed261bf4157a0dceaab20b40df103
cc53a2ee3e8592c1a194cbecb01c2938138105b193316feefb9e43db3003a16adf2f09561d3bbfb5
943243c247109a07cde67fc69b850874e1580b3f0fb0b020524b9d2c674bf39f0283f1c10cd1826f
135380079303e4af58fc0e1e9e60b8b282534614d9d6f62a17f15bb5a0dc338f2db5007a30121b25
2dcc3b393ebd66dc2ccc90998b21f0d4d8e4c91fb03e5bcc61c7e2136ae03cb5cb8302f8777ee5ac
2fca08558d149dc5ff07a662f0798116c9489324f4443473cc89247b7e968acdc1c80fd34393c4fb
f465b2b08b97fc913eaf02d967c0a5fb1ce92ebc99a3652e4e2fa4bb3d7f836a7e6a28611ab3a4f9
df7bce635a52ecb76deea24bfc9bcf6e8f2423570ac176f446bdb75e88d347d11842f7952b54caf2
c58644586cdc7c732a21b378796f670158dc073605bc3e3269b890f9c953b63068d22a5383ef4b37
ac3f9c49335da6a08fcbf5397aaf247ceb972e58c1af614dd0acd2f2637f361f73d4513224dc1fee
2f7c82fe8959551fc32a3f9e51b57de4b48928e80114812971ce6bb96cac8745d5931d0241c489d8
174edd360c80e5769145325ee39eb9b66bfeedf8258b2c81e0a3e9b081d245a6c754cdf277b2b96a
740f9b6cd50f08123c1d55e82c5430f0db3f4d84a8d11f09cb9418185d1054c1f8cef767362226b7
e7abf1f75fcc0b408bb40e02a00d1e4f4155c7ad61621be59b6f7caa75d79fb9bce55d75888ead7f
fab7dcc0134105a1bd4a263b6bc2d75a522f02ccc7d6d834f20f4e70eedc053474fc7d56bbea5ec5
dbc6e264cba3aab7a4eb1147d51c9db7a4abc14e1cb791bf68cf52bc48e63beb1c26b266a4a4f93d
a07bedd4bc8b710be5d6961346a2a0cd3c4d9a79da734a8965e3cfa93356538b4fc6dfd4a755107e
c506149de2572ef6f16d4abd377302971103631d1686010442a652655bb90d598f04c0e3495756ed
11f6160357d709bbc3a90037920218132a1fa27df0ddfb1afbeeba3afc4e6a06b59c42a54d5849c4
a722efc2e405e4f1a5a51708f666342a854a882d804cbc7f0a2d47435fe6ce7f7ddf00ac195906bf
49bbbf7e6424abc448044202087ef546abbf6a26a44e26b1503d72270b706883a5128fc01c3f2b28
7686b7fa36c08394b91fc117b29f0999cba3b56a9f9e089137477134b96700798ea3b5faa49a2d44
52175555258733d610ac9414817ca775a61fdd69deb6c00dd40f6624fbe409fa12b98ce6d3997927
6fc714b64230cee621b46126f47f4b9d5b5151fccb9efb9be4f84327ad8f94572a26e41b252fbf1d
50e98ae12b91b0e22094060817bbf5ac20f323c3c2eaf37b4c19672303db6f95ca3f019de84d8ff4
6abc0e5a6faf2bda90c6bc4d7cad68cb58d13f369a63200fc056942632c200c2d7fdc199785f26c3
cb5b9d82bb229984db05219eb7aac685aa2479fb6b645a32085178378dcc74792715dec54cb476ee
b7028a02115527cd3ef37ee68e58bdfd6335978817aa3bed75d802d0984f74b76aa97e856fd381c2
e2c1a66c572a789d4df8ff557e04295c5c7e0546167aa3e9547a3560e4828fc4bb6ebc618a03f221
85984ab0b60341605f6d354c5eca1ac1ad370d4e4cf7f8d0b81867cdd8a450a5e2031448210d8811
66693520f7158b06be71c7f3d1c5cd33246e69e601040977ef41388789caea32a309d1dcb0079f5a
b268fdd5183852ba58f9574be6f78aeeae988bc9955830655f346cbf9821c444f1be1403d981bdaf
e8fb6ffd27fca9f07f33e64b2cd8c19372f1fe17d8a368d3e7acbb32f23001180a0dde4c9ea25e63
19cce081b1009d8f25a444052c8410f0939d1b538392db17e477ed8f441843b73dac3f0e5191f9f7
962cccc414a853e0dc9f63f31d0f31fdb957dc0118d68b00eee24061b1e8f729e1f8b805de35ff18
20d80b7ba1f37f43ce6b789fccf4d4613d96cc63267637a1340cdf6205aa743a1b04d5597b162b62
6d5bd4f1740657f918af74bff3ffaf628e9fa440f74251e27299a0e438a19dd19651a3ef6031ea89
f9abaf352ee1596102a073611b919c925cd3ecf4f9a6a86f2806499de2f8b9c1a7489ecbaab383a4
b20b6ac3611f3fdcfbda31e83eadf605f0d50a493c1e23b579d467aba48006b912c3a76d5c780929
f2f290c33b36b25f966f704f78e6f790d1df363ff1954d235120534b7d254752f8ab24ff526cb033
c7c209356f42e101e31b93dae5d02bec4e4072723b8dd4eee880030c9b17f421b9a0e422aa1e1fd6
caa183c76965023dfbce2722a4b53d41bbd70202337d148b94c57dba889d8bb5c8d0ee69ac79f1e6
aa815d1fcc1a1151da84342e3481b5ec2dab0c098b0c1646d9af8d33257f77f1136d8193537d80a5
e9aa0df2a8a86e136d3ccb7f86e1f046b562ffcf8fd4bcfafed8e7b6e8a00420005be50845c7360c
5e1a5b21362989f4c2bd093c65a5551326744f7c364282e4782986cb570fe37bbfc72366ceb6b5fc
fd445113353ccbec8bbe2f5992628ca6ea95af824b4ee6bd35e9d570fd7bbe6bc300c2d77de2017e
c9cc2536aae989651355f6c5de1d98f1b7a6697efeb68340098a65837abe9570b8c7a99cc2a7db83
150ab0f72a62ff55fc3a96fdc69cc4af859e3e437540d36dbf2808cf5a8f7c6c6e04071317e28527
7307a35fac6d7efec4ea6c497b92027b6a0ac1b614da5f9ac5cf6ee329bd6d00239e4e8e9602be46
0f51a7ee31c53f6693115ea8d21972824dd7bc4869775e6eb19100df2787dc0ddb4f5cfde546772f
18233e70a5f1b287d7b28eea349e4f9aed5c01f2c4d58a926a3c4d67a0f147ed6b62a3ea2b707268
8bbe391099a4cc671c874541ef8c30dd0a1fff7f5d82a231ae1ce9cf70aed4f0376650fdbb447ab4
c7875f9ad39498eae5d600022bc5222fd6b4c9d66e37ddf6b0362801e0207a5498d72197fcbeb484
4eaf3db80d2723cacf2116ff6fd6caf08d05a803becf5ca917503418a9c221586310d2022bae75a7
74f80d025c6022abb1b10283666613ad0f47c9df3543d1eee9815bae1057ab87ce5d4168cd3d993d
daa12c86f43934fcea39e9327a56de3fd8cafeebb4acd481b0d7456971db5d4081c889c9ffcda6d6
331e7b394afa10d082b7d7b28eea6a10d10572c3a2f03fd7773f3127d5f7306157f6b0427cb2c189
3159bac3384eec7d013d23cc5cbe4b084a7377f9356a9dda0b1e53f005bbfc0e9a315c7fc27dd5c9
5de119635509141e0d451c914b51c9020a79bf70a6b16daf4aca683e09fa0c1f4058d005f2d01746
f056d0c5b8cf4bc1006b9b6eee7d5311203a240c28cd553012ed304a17972be64cbf08cb6665747a
a450ec73ac097585126e913ec77c520df64056c4d363060b17221e1c1db965f351dd9dbf9c048ecd
942bf4567b31310233025ce9d74f2c7449c7d37960a6fdb59f7b3860c1dc614418a12e7790817725
a4dc5d8bb968398f9eb5ca2ed969b52b1fb1e18378c3f809267842d01d36c3a86d2c5f666a1dde87
46031bac4b5ed9bf5ea17ea4b5378c66df1088532146dba60b971e55e3b9e6fc0450e19ef7f449b9
797fdb228d82fbecb195296a271c85fe9b13f027b4e618433703906c958a3cdb5baaee4b60f52ef2
2153d44e4adaa84f103e5673f506eab3ce6d214aed9b662cc5278dfe87362e2dc7186225d6d51a38
cd448f4d7cc147b15edd9f6f0c3445cdb61c351f59ca112c46261cf8292a94362d4cd0588071134d
4ea35cdb6eeb0ae3e319e054e6ad14723617538f63444ae1535c2084f971654f6fc387466023863c
d72b6fc2cc1e64df34d1f8ecbe9eed08a1b3bfbf2f1f0c95c31951f1b50bc68f8c0247c52012b5ae
0aeb80142b01ca3e028a6f0121346dc28705d092a7cd6835ad0b7fe6a22c40165aee53b8aa1374bb
4f70a54a33e995e3be98a865f8fdb1977d4c58dc58c49bc225ad8b8f6abeb1754502b5f6574471cc
29fa97cea6ff53e7c01ed94fec712ede517723a5a850581352d910d32c2cbe15f6d6814b9ce8fa02
f6f071fa99ad2e4daa1c444b1bfaf7dd9aac4fbead6296f23287c573a4fe7b99040ced240f124638
78ad717efc228d9c9c3ec2f0be454ebb48d9f463ec4ef603c80204bcc13c460efea054541946d676
1f8ef627c15cad01e70b5a611ce139418390d2c1763536bb91405831526529cbee76c111f747b392
9cf6196f7543669cdf182c1f5832df00da387517ab1d8b81e56bd3cb6a46cce4fa763b6a0ae6d3a5
59d57e4467ab8cc8a1fe3c2fd8161d5716568bfa85f455e78fc7463a6233b1fa81ac5786b0cdaece
3f891fa87af201bda5cf6cac8a6761ce02ddef268ac0ecc1724bf480763e330eb1b0f9649b5c7f4b
38e08960c0af9544ee6b4fd5d2d566cb1c38e54e7f0dc683eff2c55740f5b091cfaa0ede5c67cd4c
9b806d5d6b62bef0ec5dc07c993f9422c6658888c04cc2f9eae644bd0f6a123df87e135b71f71eb8
8efa7642f230da92ee7cf954e11b68b938984527a76050e7499aa42308d29c6235608e17e70e2980
cd8b515e96926afe9e7ac281b14ea0ea7c659dc84ecfc85aca7cec83f362e787562bc05d1a75bc57
fe25f57b65929663c034a4528b42bb6eee27a289aa4225673425e0e463bd93840229449d838abfc1
3294c2e6f2e0885934db165c02ef25ee3865b2a4378ca097b235039511f848b3acc1ca493241d892
3cf52ace6882ad8857355d4844599be824091e304dea19703f29877da8cff5737fcaa378df7a55ce
d7d4e48c44c91267f5e7fac33e9e427c3815ab8e9d812cccab2c5b715bb91591652c972810ebe103
a8d6e9670989c27c761c399345fd89dcb901c2ef9b17d93498b43a533e4bdbf236e0be45e3a1802c
9840861b91bcad6035f87814ca06414a8e54f549d9601d64af2333f6f88d81156d284e01fa71c31c
52be1f9d055aeedb31db1fcf9ceadf90aff1fe3e4610768d11046302c3f742caa48552956e36c643
2d2ba416976c923aca2e9432a3fe98b42e714552ddfa0257d6a2d935d34f9399b5341dd8b629891b
a917ab4103e6bf61669bcb6fd36a7656c1c2c589e86aa9b06e5502da0f93cc44bf9b097627bb643a
2e61024f2b0671984eaec0f75732a0cc10354b5d5570ffb39680537b70695d91f66b453a47a14974
eaba136c65b06d94fcae9b9c43776f9385876c6ace54cf9447a4407737d3da2db4a95778756177df
edeb93828e499601c170401f944922cddf7e0a2e57bbf8478269bd4a8d7f3e33b56ed3c659984835
643ecc80bf69aa447a0a94a095f91e43be826bc3aa1c63328519336fc08b7f563b1b66ca3fea5d73
23c6ef4e0197bd80a820bce56b0a91a62d9d3ca5a01f262b1cc72d430e084076c7a40bba2ee2f999
881c6d69167f626bf10ff3be3f2b551fc3b6cb87587b1a54ac8cbd4473558e050560cd7ade8ca63e
0b2380fdf29ac3bbf2271ce0276864029f55eda8d57864714a3c5ac12c113a504a9f53e73dcdb524
4fa530758d52af5922ee1dc3baa8bcd158c949a020f82ca0eb338ea8822314e54c85a8884def6c85
2d6a227fb5ee76061ea5de482ab8598b5647a76751e1cd853dd429cd9619fb3c0e2af6591055e263
998eb2e40daa7ebe7cdd96452d2bf4b333d546303b37087603f7810b0c75ed02cef86bf5a2bbde91
0946888cb2a8cea35a2bc22fef6e1120c651834c24567f3bf5615e5ba0aa3573ec17b9af37477fc4
7fd57ffb53cba77e055ce17f490644061522408d47cc4a1aed3a9c31b70fa1bdbce427a3f2c973dc
2e3d699325f4387c4a293ef43dce9698100a40756e2df1abecf5aa3d8a3ae0947179129acac61cfc
3728f0899b5f26fca94a875f67ba0fe2d19e1788c3e9e7c1347154ba3b498b8a303bc175f4a4ed46
a54e9168e53ba297729e1f6d657c71200b2f43df1a252ea2df5255d638d2e2af6c95d63467274a2e
950db843251f294fa228df18edc75a2c182d09f255ac7003f27e65e892b3dad7cbb727b55de845bb
62c27c45bebcaa17bc81998826df2dab43aa5177c428f9c375f52f7cb9794700e231711c2b9008bd
4224162826299d6aad4188f7a5a6b79c516edb607c02ab12868da644b0804cb8363cd8b75fc5e4e2
fdd78c4fbc0b4482db084f6df01fecc58f434a68c74356a78ec4c9534ee12103c9151d1747109beb
0fc10128b5ff9b02e98b40073e45685ac4aab80d57dc55522dc67a02a8519e9cb3c7241211d4193e
810a99a5f9ac55e3294779ac16b2de7d5f447ca27d420b0a447eea7a3ad7c1a3c5541f308994b4be
ccdad0e68c434d5c8a83454a35d02ca008791f2bde6af8adec3933376e734d43572de87825374e41
ad12c730452eb87ae955b4bfd9916af861b3d02818770668e760df3345408ecf32cd001800f11208
545e5d19c0f1d27ef49dc85ca7e8ef4647aed46b3b4b64884da341aff8ab98f06898015e1e51dec3
e73bc255bbb2b827f25405d180096632d89ebdc49d1aa3ae841a020e55c64a6cde712e51f1b79166
33e36f17ffeb110cf98ff71d7a0d35be91046fc81b352c44b46140c9d5baf077ced035143f26b5d4
b58c9499e0efba5d3eaa89a450b6129098367a79b307eee6a81cacbbf142500fc9bfbbd33fef0bde
f5c3711d1b27ee105b32c3b24977db660cb6dab68b5b4361f72189fda8ddf37ce86cc1d4d73ad125
aa9f18367f7939e76a8611a46ca15cd76c20c89aa1d2db977aa43c5d9d51cb91f0011d39f743c041
453a4e9e875342248d2480fb81eefb3acbe05559ebdbdd5abc746ddd381145303284cfccb6f5a7e9
0da2f3f0a2557148a7c74e69df5a6920db2e6a972ef99449fc8b35871728849086fbfb698dde290d
34dbbb3213a520135aa15490ef82ad7445dcade67e38f7372cb1ac9d0409d6aa061778b961eca32a
cf8f9ed425ef3b6b95dc2babdaeabf21b244abd592879e1b51a4d72af7bcc24fbb2e84cc019112df
5909d694ada2bf6a5cf670e7e4ac11c54330c105d4f3e46875d0153f310cbc63d1f692ab211b9d9d
3e0228d20f7253feda2a4b115f34eb5a4769ffd0a2028bddd9d0b4f9157a4b29eb6d8e3b73415252
0d18d5aa779b462022cb079165412ebbbd468a43adb72a41efc3fba7c192046e6edd45d61dd14f11
59b750171b8dd7e71aef7dbeaa03e508dcf02bea322e2049be8f17123914871f1cf0716c69781a7b
508c903b9f2894a8c85e9b6333d4dbec985c941a07e0a18350e5ecda200ce69eb92e9600c4d0e00f
f4d50610245501a12cac37e73e276ffbefe3551e5803f038ac99ead7135d33ea0c6ca6d765ad676d
ba352146ab9aa93d62ebdccbdd5b5b26d7f085373215bf9c8401347b3eb561a943ce84aca87a0850
65eed262bfa0a140b688a4f183c7d5470b629bdd36c94a70dc62b144bc747fbc3addcf89c93218c9
7051b7de5f1c7d275e02ab1ca13765c03c15ef38044e84e3f5cceb9fb639fa9bcac1b873b73a3670
f52bc93cd6f33f355b3a3d1ec62134bd37fa5aa7593deec0bae5dca4cefeb420ac226dd526a4a2f6
25e3a25a43c6b9186547e72fd3893133fe230a3b39ce3bc87471a685c3cd5e5fc474b5609a0e5e61
567cc4f2a7b4235b19b92d79dc1035d6c77d650e25dad74a59a57e5102c17cda349be0635a579caf
7e61c7ce81d90f145fbfe0d4f9f713a02129aa31585da2d6b562995c9cd384d585aaad79ab571fcb
f013cf17db258276d8166fd834cdb860959ca6f19821ab29ff31cbd46b10c10fe8d5e8deca441904
0ede3f5d6f608bb4d3f83b113abb5ccbf9215e4862f9126bc078e68bc1e57828717588ad594efc60
ba2f1370cabb20f81608d7ef104095e697ef426e1b01c1b1d5f1499633e9cc99aa136416dc471194
a1e5669414ac8237bf8da15cda877b4c3a14d2651ecb803cbf31189355f033ce0b4b58bc46fa9869
796b7ce6ceb8fa2132be575b0e5171c3a61353d89dc0ad82bea70f9038e936501fb3da06aca7bb6e
129850e37f9af4fdd8d525320eec1b441a695eb733ea5eedd18c31a902c3b142460f7635530c289c
dc91222d5a8bd6496e98039cade46bd1b93a36dd1b984eeee9f22505e2105a2725dcf3a8a1093e1e
02087fa68168d65537e18fe36a4499c6755eeb154c8ccc0ac4a75023f041c0ebc3179dc8a0dcba53
b00c16dac9aa200f245f040ac1d2777ee085cd24bea66e12d9d5e1dc520512641332e5c91d02c956
3b99c8a92aefb68cfa374cd5877bf1a4c658a0b3b5aaeaad88278f1fb95d5ba35f6509d0f364a2e9
e0ff33337042284594895577a92f48cf4b8a8654ee7f3572991db83f0e0b39608b314a56c703ee5c
42197f8365a348b4b1f5eb8a792c23c4b5ca28b0003be8f80e4a86331ddee52df2af9529af8cb8fb
afac4d4b0818a97b9d05f15b2ef168b2aaaa55b183bfae7a986417bd994e653ac5cf6a8081722d3b
c4d7fad0789750891c4ff8e9ddd9bd7096bbd77c7983f140781531f4bf1f3c60f6be5ba778faa869
6694a72be5c27f890ef46d2a4d5ebbe2a540800259bf53a1925eb7b30b4fdbaff08517b564846bf9
384dc9fdf0714865834b47fd0a0dfa80a91de4aafff81f9ab701b813d1e106aeba02d779784dfdeb
f6e4cdeb0751347505b271705ce13e709394d979300164e2aa9662c79cf15df6fb971116e243cde4
471d30f1375e407f68c29076457421d799becb096f55cca9106bb3c7c219145072ed45aeff42423d
9a5b4c49924a31a3422bf479850e07d6ef9c059df47988269f8c4c8a2a62dcee9d9529492d1f6700
519d8e6ee516deaf898718e876a6435c430d7d8a528cbffc8ba55ae07761a04bc65ed28f72a3eb24
604e47a5a7773f1c68e5b87df610afac8db6f814d290e21424b2f7ebf89fcadf9bd2afa002dc0ec6
e331fc338bf98525398c14fab622dcc56f1a60ab56ab978c372a341044d5f7452971a9b0e9aca780
84b2c4a9e18dd2425c9ac859b005ddb24da9cd116a4bb938045890e874470bcc4f8d8ca4636c32dc
4e49fdeee4e0006ee6bd5b9acf56b71569bf3712401c234f0b6ab1efb142be824d02dd35187c582e
448dc3c1354cc070a89b93a986d417e67aa4c522b6806a38a683ccc127038266b4cc46285bf183b7
b805c7152f1e050ede77129a5f1f23887f79d2501ed65eaa32a037e03728ecf2ef3ebabaf60f212b
19a460bbc4ba31edb2db905b06034ef48f8d7d651a9cc181ee7f18af34403bfda229a73914d42393
a8be7aa5ce21ddcb8e1f2e94cc1b505af464a944baa3ada3dc0bb1b27ffd59852dffc70252d5af39
d4ad8de4711cc3d946daf0d312d48d4f2488f8a7e437ff2cde13d72c83a42a670bfd75dbdec81e7c
98a47513d4d065790d19579d1132d8eb43f839d846791443434ea3ca8e817d542defaff0f110a635
0d9e036c38f9eaa53f0ff40defb98563acaba4f4dbed1dbb3b4e28da7524daa2fc9d31dcecd54333
73f18290f0f4a7e7322f4749d91843c9e3c5686efa3abbfb9a676117771f0056907cbcac9ffe7f0d
27209a22d20e4bd3070176dec667fc88bf09562688bedc6a04deb53b3520a397a0e1a6aed45a7a46
b68fff8ef194b471ffbba847b86e8aa874ad1c1ffb4c51e6c3a4104789ea9ce1cb5a9c1d81e8ba21
5d4b4ae3f035dc0765bb7869e57f76c5264ba37f171b7f8d9793b5
#END

#BEGIN DEVICE
	@LocalIOMaster, 12, 27
	@RamFS, 1, 1
	@UserLog, 7, 11
	@IntEthernet, 4, 2
	@DMLogger, 5, 10
	@IntModTCPClient, 9, 14, 1000, 2, 60
	@IntEIPClient, 22, 31, 1000, 2, 60
	@IntEthDMPPClient, 23, 32, 50, 250, 2
	@IntSerial, 10, 15
#END

#BEGIN MEM_CONFIG
	X	BIT	decimal	2048	-1
	Y	BIT	decimal	2048	-1
	WX	SWORD	decimal	256	-1
	WY	SWORD	decimal	256	-1
	C	BIT	decimal	2048
	V	UWORD	decimal	4096
	N	SWORD	decimal	4096
	D	SDWORD	decimal	4096
	R	REAL	decimal	4096
	T	TIMER	decimal	256
	CT	COUNTER	decimal	256
	SS	STRING	decimal	128
	SL	STRING	decimal	64
	UDT	DATETIME	decimal	32
	PL	UWORD	decimal	256
	DLX	BIT	octal	01000	-1
	DLY	BIT	octal	01000	-1
	DLC	BIT	octal	01000
	DLV	UWORD	octal	04000
	MI	BIT	decimal	1024
	MC	BIT	decimal	1024
	MIR	SWORD	decimal	2048
	MHR	SWORD	decimal	2048
	RX	REAL	decimal	256	-1
	RY	REAL	decimal	256	-1
	STKC	BIT	decimal	256
	STKD	SWORD	decimal	64
	STKT	TIMER	decimal	64
	MSG	STRING		0
	ERR	STRING		0
	SysName	STRING		0
	SysDesc	STRING		0
	SerialNum	STRING		0
	PartNum	STRING		0
	NewStker	PROGRAM		0	-1
	TestNewStker	PROGRAM		0	-1
	Stkr_SetState	<Virtual>		0
	Stkr_DetectState	<Virtual>		0
	stkr_CycleState	TASK		0	-1
	tst_mock_stkr	<Virtual>		0
	mock_stkrStart	TASK		0	-1
	stkr_BufferX	TASK		0	-1
	mock_stkrCycle	TASK		0	-1
	stkr_BufferY	TASK		0	-1
	Run	PROGRAM		0	-1
	Glue	PROGRAM		0	-1
	tst_stkBufferY	TASK		0	-1
	TestTimer	PROGRAM		0	-1
#END

// Beginning of Code Block Stkr_SetState
$LGCMOD	Stkr_SetState

// Rung Stkr_SetState#1
// Offset 0
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set Stacker States<br>"
"#########################################<br> <br>Set Rest "
"State"
#END

STRE	STKD43	0
SET	STKC10
RST	STKC11
RST	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#2
// Offset 9
#BEGIN FMT_COMMENT 
"Set Ejection / Compression  State"
#END

STRE	STKD43	1
RST	STKC10
SET	STKC11
SET	STKC12
RST	STKC13
RST	STKC14

// Rung Stkr_SetState#3
// Offset 18
#BEGIN FMT_COMMENT 
"Set Transfer State"
#END

STRE	STKD43	2
RST	STKC10
RST	STKC11
SET	STKC12
SET	STKC13
RST	STKC14

// Rung Stkr_SetState#4
// Offset 27
#BEGIN FMT_COMMENT 
"Set Load State"
#END

STRE	STKD43	3
SET	STKC10
RST	STKC11
RST	STKC12
SET	STKC13
SET	STKC14

// Rung Stkr_SetState#5
// Offset 36
NOP

// Rung Stkr_SetState#6
// Offset 37
NOP

// Rung Stkr_SetState#7
// Offset 38
RET

// End of Code Block Stkr_SetState
$LGCEND	Stkr_SetState

// Beginning of Code Block Stkr_DetectState
$LGCMOD	Stkr_DetectState

// Rung Stkr_DetectState#1
// Offset 0
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Operational States #######################<br>"
"#########################################<br> <br>Detect "
"States<br>#########################################<br> <br>"
"Trasition State"
#END

STR	ST1
MATH	STKD42	"-1"

// Rung Stkr_DetectState#2
// Offset 8
#BEGIN FMT_COMMENT 
" Reset State"
#END

STR	X5
ANDN	X6
AND	X8
AND	X7
AND	X9
AND	X10
MATH	STKD42	"0"

// Rung Stkr_DetectState#3
// Offset 20
#BEGIN FMT_COMMENT 
"Ejection / Compression State"
#END

STRN	STKC0
AND	STKC1
AND	STKC2
AND	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"1"

// Rung Stkr_DetectState#4
// Offset 32
#BEGIN FMT_COMMENT 
"Transfer State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
AND	STKC4
AND	STKC5
MATH	STKD42	"2"

// Rung Stkr_DetectState#5
// Offset 44
#BEGIN FMT_COMMENT 
"Load State"
#END

STR	STKC0
ANDN	STKC1
ANDN	STKC2
ANDN	STKC3
ANDN	STKC4
ANDN	STKC5
MATH	STKD42	"3"

// Rung Stkr_DetectState#6
// Offset 56
NOP

// Rung Stkr_DetectState#7
// Offset 57
NOP

// Rung Stkr_DetectState#8
// Offset 58
NOP

// Rung Stkr_DetectState#9
// Offset 59
RET

// End of Code Block Stkr_DetectState
$LGCEND	Stkr_DetectState

// Beginning of Code Block tst_mock_stkr
$LGCMOD	tst_mock_stkr

// Rung tst_mock_stkr#1
// Offset 0
#BEGIN FMT_COMMENT 
"##################################################<br>"
"##  MOCKS  #######################################<br>"
"##################################################<br> "
"<br>Mock Stacker Operation Reset State"
#END

STRE	D50	0
SET	X5
RST	X5
SET	X8
SET	X7
SET	X9
SET	X10

// Rung tst_mock_stkr#2
// Offset 10
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Ejection / Compression "
#END

STRE	D50	1
RST	X5
SET	X5
SET	X8
SET	X7
SET	X9
SET	X10

// Rung tst_mock_stkr#3
// Offset 20
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Transfer State"
#END

STRE	D50	2
SET	X5
RST	X5
RST	X8
RST	X7
SET	X9
SET	X10

// Rung tst_mock_stkr#4
// Offset 30
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Load State"
#END

STRE	D50	3
SET	X5
RST	X5
RST	X8
RST	X7
RST	X9
RST	X10

// Rung tst_mock_stkr#5
// Offset 40
#BEGIN FMT_COMMENT 
"Mock Stacker Operation Broken State"
#END

STRE	D50	5
SET	X5
SET	X5
SET	X8
SET	X7
SET	X9
SET	X10

// Rung tst_mock_stkr#6
// Offset 50
NOP

// Rung tst_mock_stkr#7
// Offset 51
RET

// End of Code Block tst_mock_stkr
$LGCEND	tst_mock_stkr

// Beginning of Code Block $Main
$PRGRM	$Main

// Rung $Main#1
// Offset 0
STR	C200
DUPBOOL
ANDPDPF
RUN	NewStker
POPBOOL
NOT
HALT	NewStker
OUT	C700

// Rung $Main#2
// Offset 9
STR	C201
DUPBOOL
ANDPDPF
RUN	Glue
POPBOOL
NOT
HALT	Glue

// Rung $Main#3
// Offset 17
STR	C203
DUPBOOL
ANDPDPF
RUN	TestNewStker
POPBOOL
NOT
HALT	TestNewStker

// Rung $Main#4
// Offset 25
STR	C204
ENTASK	tst_stkBufferY	0x0	0	0x1
NOT
HALT	tst_stkBufferY

// Rung $Main#5
// Offset 32
STR	C202
RUN	TestTimer
NOT
HALT	TestTimer

// End of Code Block $Main
$PGMEND	$Main

// Beginning of Code Block stkr_BufferX
$TSK	stkr_BufferX

// Rung stkr_BufferX#1
// Offset 0
STR	X5
ONDTMR	STKT0	STKD0	STKC0

// Rung stkr_BufferX#2
// Offset 4
STR	X6
ONDTMR	STKT1	STKD1	STKC1

// Rung stkr_BufferX#3
// Offset 8
STR	X8
ONDTMR	STKT2	STKD2	STKC2

// Rung stkr_BufferX#4
// Offset 12
STR	X7
ONDTMR	STKT3	STKD3	STKC3

// Rung stkr_BufferX#5
// Offset 16
STR	X9
ONDTMR	STKT4	STKD4	STKC4

// Rung stkr_BufferX#6
// Offset 20
STR	X10
ONDTMR	STKT5	STKD5	STKC5

// End of Code Block stkr_BufferX
$TSKEND	stkr_BufferX

// Beginning of Code Block NewStker
$PRGRM	NewStker

// Rung NewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"#########################################<br>"
"##  RUN STATES  ##########################<br>#########################################"
#END

NOP

// Rung NewStker#2
// Offset 1
#BEGIN FMT_COMMENT 
"Begin Buffering Air Cylinder Outputs"
#END

STR	ST1
ENTASK	stkr_BufferY	0x0	0	0x1

// Rung NewStker#3
// Offset 6
#BEGIN FMT_COMMENT 
"Begin Buffering Eye inputs"
#END

STR	ST1
ENTASK	stkr_BufferX	0x0	0	0x1

// Rung NewStker#4
// Offset 11
#BEGIN FMT_COMMENT 
"#################################################<br>"
"## Error handling ###################################<br>"
"#################################################<br> "
#END

STR	X2
TIMEDOUT	1000	STKC30	0x1

// Rung NewStker#5
// Offset 16
#BEGIN FMT_COMMENT 
"Machine Pre-Run Error"
#END

STRN	X32
ORN	X0
ORN	X1
STR	Y0
ANDN	STKC30
ORSTR
OUT	STKC120
OUT	Y0

// Rung NewStker#6
// Offset 24
#BEGIN FMT_COMMENT 
"Machine Runtime Error"
#END

STR	STKC122
OR	STKC123
OUT	STKC121
OUT	Y1

// Rung NewStker#7
// Offset 28
STR	STKC30
ANDE	STKD42	0
RST	STKC122
RST	STKC123

// Rung NewStker#8
// Offset 35
STR	STKC30
ANDN	STKC120
ANDN	X3
ANDNE	STKD43	0
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"

// Rung NewStker#9
// Offset 51
#BEGIN FMT_COMMENT 
"#################################################<br>"
"## Start up ########################################<br>"
"#################################################<br> "
"<br>Pre-Run Setup"
#END

STRN	STKC121
OR	STKC30
ANDN	STKC120
OUT	Y2

// Rung NewStker#10
// Offset 55
#BEGIN FMT_COMMENT 
"Machine On State"
#END

STRN	STKC120
ANDN	STKC121
AND	X3
ANDN	STKC30
STR	STKC100
STRE	STKD42	0
ANDE	STKD43	0
ORSTR
ANDSTR
OUT	STKC100
OUT	Y10

// Rung NewStker#11
// Offset 72
NOP

// Rung NewStker#12
// Offset 73
#BEGIN FMT_COMMENT 
"#########################################<br> <br> <br>"
"Set States<br>#########################################<br>"
" <br>Detect State"
#END

STR	ST1
CALL	Stkr_DetectState	0x1	DST511	"3"	"3"

// Rung NewStker#13
// Offset 81
STR	STKC100
ANDN	STKC31
ENTASK	stkr_CycleState	0x0	0	0x1

// Rung NewStker#14
// Offset 87
STRN	STKC100
OR	STKC31
HALT	stkr_CycleState

// End of Code Block NewStker
$PGMEND	NewStker

// Beginning of Code Block stkr_CycleState
$TSK	stkr_CycleState

// Rung stkr_CycleState#1
// Offset 0
#BEGIN FMT_COMMENT 
"Reset variables for first cycle"
#END

STRPD	ST1
RST	STKC40
RST	STKC41
MATH	STKD45	"0"
MATH	STKD40	"0"
MATH	STKD41	"0"
MATH	D2	"0"
MATH	STKD43	"0"
MATH	STKD50	"0"
MATH	STKD51	"0"

// Rung stkr_CycleState#2
// Offset 46
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Transition States #########################<br>"
"#########################################<br> <br>Cycle "
"States<br>#########################################<br> <br>"
" <br>    1. Set a bit for every latch cam cycle.  If this "
"bit is not <br>        reset by the time the next cam cycle "
"comes around<br>"
"        it will thorw a Cam Latch Missed error (our cycle "
"is taking too long)<br>        "
#END

STRPD	X4
AND	STKC43
AND	ST2
SET	STKC123
RST	STKC43

// Rung stkr_CycleState#3
// Offset 52
STRPD	X4
SET	STKC43

// Rung stkr_CycleState#4
// Offset 55
#BEGIN FMT_COMMENT 
"    2. Determine if stacker should transition state.<br>"
"        * If stacker is in Reset State only cycle if<br>"
"           the latch cam is detected.<br>"
"        * If the cycle is not between state and not "
"<br>           in the reset state.<br>"
"        * aditionally the timers must not have started "
"<br>           yet (its the first scan), or the lockout "
"timer <br>           for the current Cycle State must be "
"expired."
#END

STRE	STKD42	STKD43
ANDGT	STKD42	0
AND	STKT40.Done
STRE	STKD42	0
AND	X4
STR	STKT40.Done
ORN	STKC40
ANDSTR
ORSTR
ANDNE	STKD42	-1
SET	STKC45
SET	STKC40

// Rung stkr_CycleState#5
// Offset 79
STR	X3
ONDTMR	T1	4500	C4

// Rung stkr_CycleState#6
// Offset 83
STR	C4
AND	STKC45
SET	STKC41
RST	STKC45

// Rung stkr_CycleState#7
// Offset 87
#BEGIN FMT_COMMENT 
"    3.  Get variables for state transition<br>"
"        * Each Cycle State as three variables associated "
"<br>           with it:<br>"
"            - Stacker Operation Next Cycle State:<br>"
"                    the next state to cycle to.<br>"
"            - Stacker Operation Lockout ms<br>"
"                    time after transition before a "
"transition <br>"
"                    can be considered again.  Minimum "
"<br>                    transition time.<br>"
"            - Stacker Operation Timout ms<br>"
"                    time after transition before an error "
"is<br>                    thrown.  Maximum transition "
"time.<br>         * Note: Transitioning from Reset State to "
"Ejection State<br>"
"            must reset the Latch Cam Open bit or it is "
"assumed<br>            we missed the cycle and a Missed "
"Latch Cam Cycle <br>            error will be thrown at the "
"end.<br>         * Note: There is no way to detect the "
"trasition between            <br>            Ejection State "
"and Compression State, so we must <br>            also test "
"those states agains the Stacker Operation <br>            "
"State Set to determine the expected state."
#END

STR	STKC41
DUPBOOL
ANDE	STKD42	0
MATH	STKD45	"1"
MATH	STKD40	"1500"
MATH	STKD41	"2000"
RST	STKC43
POPBOOL
DUPBOOL
ANDE	STKD42	1
MATH	STKD45	"2"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
DUPBOOL
ANDE	STKD42	2
MATH	STKD45	"3"
MATH	STKD40	"1000"
MATH	STKD41	"1500"
POPBOOL
ANDE	STKD42	3
MATH	STKD45	"0"
MATH	STKD40	"1000"
MATH	STKD41	"0"

// Rung stkr_CycleState#8
// Offset 183
#BEGIN FMT_COMMENT 
"    5. Start lockout time for transition<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection.<br>"
"        * Transitioning is not allowed while lockout<br>"
"           timer is powered and != Done."
#END

STR	STKC40
ANDGT	STKD50	0
STRPD	STKC41
TMRA	STKT40	STKD40

// Rung stkr_CycleState#9
// Offset 192
STRPD	STKC41
MATH	STKD50	"STKD40"

// Rung stkr_CycleState#10
// Offset 200
#BEGIN FMT_COMMENT 
"##############################################################<br>"
" <br>#########################################<br>"
"##  Error Trapping ###########################<br>"
"#########################################<br> <br>    6. "
"Test for timeout on state transition<br>"
"        * If the machine takes too long between transitions "
"it is <br>          considered in a broken state.<br>"
"        * Begin Timers bit prevents the timer<br>"
"           from running before the machine starts<br>"
"           it is triggered by the first Latch Cam Cycle<br>"
"           detection."
#END

STR	STKC40
ANDGT	STKD51	0
STRPD	STKC41
TMRA	STKT41	STKD41

// Rung stkr_CycleState#11
// Offset 209
STRPD	STKC41
MATH	STKD51	"STKD41"

// Rung stkr_CycleState#12
// Offset 217
STR	STKC40
AND	STKT41.Done
ANDGT	STKD41	0
SET	STKC122

// Rung stkr_CycleState#13
// Offset 224
#BEGIN FMT_COMMENT 
"4. Set the new Cycle State"
#END

STR	STKC41
CALL	Stkr_SetState	0x1	DST511	"3 STKD45 STKD43 1"	"3"
RST	STKC41

// Rung stkr_CycleState#14
// Offset 235
NOP

// End of Code Block stkr_CycleState
$TSKEND	stkr_CycleState

// Beginning of Code Block stkr_BufferY
$TSK	stkr_BufferY

// Rung stkr_BufferY#1
// Offset 0
STR	STKC10
ONDTMR	STKT15	STKD15	STKC15

// Rung stkr_BufferY#2
// Offset 4
STRND	STKC15
OFFDTMR	STKT16	STKD16	STKC16

// Rung stkr_BufferY#3
// Offset 9
STR	STKC11
ONDTMR	STKT17	STKD17	STKC17
ANDNDPF
OFFDTMR	STKT18	STKD18	STKC18

// Rung stkr_BufferY#4
// Offset 17
STR	STKC12
ONDTMR	STKT19	STKD19	STKC19
ANDNDPF
OFFDTMR	STKT20	STKD20	STKC20

// Rung stkr_BufferY#5
// Offset 25
STR	STKC13
ONDTMR	STKT21	STKD21	STKC21
ANDNDPF
OFFDTMR	STKT22	STKD22	STKC22

// Rung stkr_BufferY#6
// Offset 33
STR	STKC14
ONDTMR	STKT23	STKD23	STKC23

// Rung stkr_BufferY#7
// Offset 37
STRND	STKC23
OFFDTMR	T210	STKD24	C2005

// Rung stkr_BufferY#8
// Offset 42
STR	STKC15
OR	STKC16
OUT	Y9

// Rung stkr_BufferY#9
// Offset 45
STR	STKC17
OR	STKC18
OUT	Y8

// Rung stkr_BufferY#10
// Offset 48
STR	STKC19
OR	STKC20
OUT	Y5

// Rung stkr_BufferY#11
// Offset 51
STR	STKC21
OR	STKC22
OUT	Y4

// Rung stkr_BufferY#12
// Offset 54
STR	STKC23
AND	C2000
STR	C2005
AND	C2001
ORSTR
OUT	Y3

// Rung stkr_BufferY#13
// Offset 60
NOP

// End of Code Block stkr_BufferY
$TSKEND	stkr_BufferY

// Beginning of Code Block TestNewStker
$PRGRM	TestNewStker

// Rung TestNewStker#1
// Offset 0
#BEGIN FMT_COMMENT 
""
"##################################################<br>"
"## Tests  ##########################################<br>"
"##################################################<br> "
"<br>##################################################<br> "
"<br>Initialize Variables<br>##################################################"
#END

STRPD	ST1
RSTR	C400	C449
RSTR	C600	C649
SET	STKC31

// Rung TestNewStker#2
// Offset 7
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Set Up Mocks<br>"
"#################################################<br> "
"<br>    Mock Stacker Start"
#END

STR	C408
ENTASK	mock_stkrStart	0x0	0	0x1
NOT
HALT	mock_stkrStart

// Rung TestNewStker#3
// Offset 14
STR	STKC100
RST	C408

// Rung TestNewStker#4
// Offset 16
#BEGIN FMT_COMMENT 
"    Mock Stacker Cycle"
#END

STR	C406
ENTASK	mock_stkrCycle	0x0	0	0x1
NOT
HALT	mock_stkrCycle

// Rung TestNewStker#5
// Offset 23
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Run Tests<br>"
"#################################################<br> "
"<br>    1. Mock Stacker Reset State"
#END

STRPD	ST1
ANDN	C600
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"

// Rung TestNewStker#6
// Offset 35
#BEGIN FMT_COMMENT 
"    2. Mock Turn on Stacker"
#END

STRPD	ST1
ANDN	C600
SET	C408

// Rung TestNewStker#7
// Offset 39
STR	STKC100
SET	C600

// Rung TestNewStker#8
// Offset 41
NOP

// Rung TestNewStker#9
// Offset 42
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Pre-Run Error<br>"
"#################################################<br> "
"<br>    2. Make sure Run State stopped and error was raised "
"before restarting<br>"
"        * Mock restart stacker already clears errors."
#END

STR	C600
ANDN	C601
ANDN	STKC100
AND	STKC120
SET	C408

// Rung TestNewStker#10
// Offset 47
#BEGIN FMT_COMMENT 
"    1. Mock Pre-run error<br>"
"        * make sure stacker is running for this test"
#END

STR	C600
ANDN	C601
ANDN	C409
AND	STKC100
RST	X0
SET	C409

// Rung TestNewStker#11
// Offset 53
#BEGIN FMT_COMMENT 
"     3. Confirm error cleared and stacker restarted"
#END

STR	C600
ANDN	C601
AND	X0
AND	C409
AND	STKC100
SET	C601
RST	C409

// Rung TestNewStker#12
// Offset 60
#BEGIN FMT_COMMENT 
"#################################################<br> <br>"
"Test Stacker Run-Time Error<br>"
"#################################################<br> "
"<br>    2. Clear error and attemp restart, which should "
"fail due<br>"
"         the stacker not being a Reset State.  Use a timer "
"to<br>         confirm the Mock Start Up had time to try "
"and start."
#END

STR	C601
ANDN	C602
AND	C409
RST	STKC123
ANDN	STKC123
SET	C408
TMR	T200	1000

// Rung TestNewStker#13
// Offset 68
#BEGIN FMT_COMMENT 
"    1. Set cycle state to something other than reset<br>"
"        so stacker error can't be cleared.  Then mock error."
#END

STR	C601
ANDN	C602
DUPBOOL
ANDPDPF
ANDNE	D50	3
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
ANDE	D50	3
SET	STKC123
SET	C409

// Rung TestNewStker#14
// Offset 92
#BEGIN FMT_COMMENT 
"    3. If the timer experied and the stacker still hasn't "
"started<br>        we can be confident it won't start in "
"when the cycle is<br>        not in a Reset State."
#END

STR	C601
ANDN	C602
AND	T200.Done
ANDN	STKC100
SET	C410

// Rung TestNewStker#15
// Offset 97
#BEGIN FMT_COMMENT 
"    5. Confirm the Stacker Cycle is now in a Reset State "
"and <br>        attempt to start again."
#END

STR	C601
ANDN	C602
AND	C410
ANDE	D50	0
SET	C408

// Rung TestNewStker#16
// Offset 105
#BEGIN FMT_COMMENT 
"    4. Mock setting the Cycle State to the Reset State.<br>"
"        Stop the Mock Restart from running."
#END

STR	C601
ANDN	C602
AND	C410
ANDNE	D50	0
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
RST	C408

// Rung TestNewStker#17
// Offset 122
#BEGIN FMT_COMMENT 
"    6. Confirm start was successful this time."
#END

STR	C601
ANDN	C602
ANDN	STKC123
AND	C410
AND	STKC100
SET	C602
RSTR	C409	C410

// Rung TestNewStker#18
// Offset 130
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Detect States Test<br>"
"#################################################<br> "
"<br>     1. Mock each Cycle State one by one."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	tst_mock_stkr	0x1	DST511	"3 1 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	tst_mock_stkr	0x1	DST511	"3 2 D50 1"	"3"
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
POPBOOL
AND	C412
ANDN	C413
CALL	tst_mock_stkr	0x1	DST511	"3 5 D50 1"	"3"

// Rung TestNewStker#19
// Offset 194
#BEGIN FMT_COMMENT 
"    2. Test every scan to confirm the Cycle State was "
"changed to the <br>         next state."
#END

STR	C602
ANDN	C603
DUPBOOL
ANDN	C409
ANDE	D12	0
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
ANDE	D12	1
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
ANDE	D12	2
SET	C411
POPBOOL
DUPBOOL
AND	C411
ANDN	C412
ANDE	D12	3
SET	C412
POPBOOL
AND	C412
ANDN	C413
ANDE	D12	-1
SET	C413

// Rung TestNewStker#20
// Offset 238
#BEGIN FMT_COMMENT 
"    3. Detect the state so it can be tested next scan."
#END

STR	C602
ANDN	C603
CALL	Stkr_DetectState	0x1	DST511	"3"	"3 STKD42 D12 1"

// Rung TestNewStker#21
// Offset 249
#BEGIN FMT_COMMENT 
"    4. Confirm all states have been detected once."
#END

STR	C602
ANDN	C603
AND	C409
AND	C410
AND	C411
AND	C412
AND	C413
SET	C603
RSTR	C409	C414

// Rung TestNewStker#22
// Offset 259
NOP

// Rung TestNewStker#23
// Offset 260
NOP

// Rung TestNewStker#24
// Offset 261
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Set States Test<br>"
"#################################################<br> "
"<br>    1. Set each Cycle State one by one after each state "
"has been<br>        confirmed."
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
CALL	Stkr_SetState	0x0	DST511	"3 0 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
CALL	Stkr_SetState	0x0	DST511	"3 1 STKD43 1"	"3"
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
CALL	Stkr_SetState	0x0	DST511	"3 2 STKD43 1"	"3"
POPBOOL
AND	C411
ANDN	C412
CALL	Stkr_SetState	0x0	DST511	"3 3 STKD43 1"	"3"

// Rung TestNewStker#25
// Offset 316
#BEGIN FMT_COMMENT 
"    2. Test each cycle to see a state has been "
"successfully set"
#END

STR	C603
ANDN	C604
DUPBOOL
ANDN	C409
AND	Y9
ANDN	Y8
ANDN	Y5
ANDN	Y4
ANDN	Y3
SET	C409
POPBOOL
DUPBOOL
AND	C409
ANDN	C410
ANDN	Y9
AND	Y8
AND	Y5
ANDN	Y4
ANDN	Y3
SET	C410
POPBOOL
DUPBOOL
AND	C410
ANDN	C411
AND	Y9
ANDN	Y8
AND	Y5
AND	Y4
ANDN	Y3
SET	C411
POPBOOL
AND	C411
ANDN	C412
AND	Y9
ANDN	Y8
ANDN	Y5
AND	Y4
AND	Y3
SET	C412

// Rung TestNewStker#26
// Offset 355
#BEGIN FMT_COMMENT 
"    3. Confirm all states have been set at least once."
#END

STR	C603
ANDN	C604
AND	C409
AND	C410
AND	C411
AND	C412
SET	C604
RSTR	C409	C413

// Rung TestNewStker#27
// Offset 364
#BEGIN FMT_COMMENT 
" ################################################# <br> "
"<br> <br> <br>"
" ################################################# <br>"
"Cycle State<br>"
"#################################################<br> <br> "
#END

NOP

// Rung TestNewStker#28
// Offset 365
#BEGIN FMT_COMMENT 
"    2. Delay starting the Cycle Mock to test that the "
"Cycle Task<br>"
"        can run without the machine on.  In production the "
"Task<br>        will always turn on before the machine and "
"will wait for the first <br>        Latch Cam Cycle to "
"trigger its logic."
#END

STR	C604
ANDN	C605
ANDN	STKC31
DUPBOOL
AND	ST1
TMR	T201	2000
POPBOOL
DUPBOOL
AND	ST1
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
AND	T201.Done
AND	ST1
SET	C406

// Rung TestNewStker#29
// Offset 398
#BEGIN FMT_COMMENT 
"    1. Turn on the stkr_CycleState state task for testing"
#END

STR	C604
ANDN	C605
AND	STKC31
RST	STKC31

// Rung TestNewStker#30
// Offset 402
STR	C604
ANDN	C605
MATH	D6	"(CT0.Acc == CT1.Acc) && (CT0.Acc == CT2.Acc) && (CT0.Acc == CT3.Acc) && (CT0.Acc == CT4.Acc)"

// Rung TestNewStker#31
// Offset 424
#BEGIN FMT_COMMENT 
" "
#END

STR	C604
ANDN	C605
AND	STKC100
ANDE	CT0.Acc	4
ANDE	D6	1
SET	C605
RST	C420
RST	C406

// Rung TestNewStker#32
// Offset 438
STR	ST1
STR	ST0
CNT	CT6	D80

// End of Code Block TestNewStker
$PGMEND	TestNewStker

// Beginning of Code Block mock_stkrStart
$TSK	mock_stkrStart

// Rung mock_stkrStart#1
// Offset 0
STR	C407
RST	X2

// Rung mock_stkrStart#2
// Offset 2
#BEGIN FMT_COMMENT 
"Turn On Stacker"
#END

STRPD	ST1
SET	X0
SET	X32
SET	X1
SET	X2
OUT	C407

// Rung mock_stkrStart#3
// Offset 9
STRN	X2
ANDE	STKD43	0
SET	X3

// Rung mock_stkrStart#4
// Offset 15
NOP

// End of Code Block mock_stkrStart
$TSKEND	mock_stkrStart

// Beginning of Code Block mock_stkrCycle
$TSK	mock_stkrCycle

// Rung mock_stkrCycle#1
// Offset 0
#BEGIN FMT_COMMENT 
"1. Initialize stacker Cycle State to the Reset State"
#END

STRPD	ST1
DUPBOOL
ANDNE	STKD42	0
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 0 D50 1"	"3"
POPBOOL
DUPBOOL
ANDNE	STKD43	0
ANDPDPF
CALL	Stkr_SetState	0x1	DST511	"3 0 STKD43 1"	"3"
POPBOOL
AND	ST1
MATH	D27	"6000"
RST	C427

// Rung mock_stkrCycle#2
// Offset 42
#BEGIN FMT_COMMENT 
"2. Mock the cam cycling"
#END

STR	ST1
FLASHER	100	D27	C420

// Rung mock_stkrCycle#3
// Offset 47
STR	ST1
DUPBOOL
AND	C420
SET	X4
POPBOOL
ANDN	C420
RST	X4

// Rung mock_stkrCycle#4
// Offset 54
#BEGIN FMT_COMMENT 
"3. Mock the input values for each Cycle State after the "
"<br>        outputs reach the corrosponding Cycle State."
#END

STR	ST1
DUPBOOL
AND	Y9
ANDN	Y8
ANDN	Y5
ANDN	Y4
ANDN	Y3
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 0 D50 1"	"3"
OUT	C421
POPBOOL
DUPBOOL
AND	Y9
AND	Y8
ANDN	Y5
ANDN	Y4
ANDN	Y3
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 1 D50 1"	"3"
OUT	C422
POPBOOL
DUPBOOL
ANDN	Y9
AND	Y8
AND	Y5
ANDN	Y4
ANDN	Y3
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 2 D50 1"	"3"
OUT	C423
POPBOOL
DUPBOOL
ANDN	Y9
ANDN	Y8
AND	Y5
AND	Y4
ANDN	Y3
ANDPDPF
CALL	tst_mock_stkr	0x1	DST511	"3 3 D50 1"	"3"
OUT	C424
POPBOOL
AND	Y9
ANDN	Y8
ANDN	Y5
AND	Y4
AND	Y3
ANDPDPF
CALL	tst_mock_stkr	0x0	DST511	"3 4 D50 1"	"3"
OUT	C425

// Rung mock_stkrCycle#5
// Offset 147
#BEGIN FMT_COMMENT 
"    4. Count each new state set for testing.<br>"
"        <br>        * Count Reset State Set"
#END

STR	C421
STRPD	ST1
CNT	CT0	D20

// Rung mock_stkrCycle#6
// Offset 152
#BEGIN FMT_COMMENT 
"        * Count Ejection State Set"
#END

STR	C422
STRPD	ST1
CNT	CT1	D21

// Rung mock_stkrCycle#7
// Offset 157
#BEGIN FMT_COMMENT 
"        * Count Compression State Set"
#END

STR	C423
STRPD	ST1
CNT	CT2	D22

// Rung mock_stkrCycle#8
// Offset 162
#BEGIN FMT_COMMENT 
"        * Count Transition State Set"
#END

STR	C424
STRPD	ST1
CNT	CT3	D23

// Rung mock_stkrCycle#9
// Offset 167
#BEGIN FMT_COMMENT 
"        * Count Load State Set"
#END

STR	C425
STRPD	ST1
CNT	CT4	D24

// Rung mock_stkrCycle#10
// Offset 172
#BEGIN FMT_COMMENT 
"    5. Count each transition for testing."
#END

STR	C413
STRPD	ST1
CNT	CT5	D25

// Rung mock_stkrCycle#11
// Offset 177
#BEGIN FMT_COMMENT 
"    6. Random Transition Offset"
#END

STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
ANDGT	STKD40	0
ANDPDPF
MATH	D26	"(((STKD41 - 5) - STKD40) * RANDREAL()) + STKD40"
SET	C427

// Rung mock_stkrCycle#12
// Offset 202
STR	ST1
STR	C421
OR	C422
OR	C423
OR	C424
OR	C425
TMRA	T202	D26

// End of Code Block mock_stkrCycle
$TSKEND	mock_stkrCycle

// Beginning of Code Block Run
$PRGRM	Run

// Rung Run#1
// Offset 0
#BEGIN FMT_COMMENT 
"#############################################<br>"
"## Buffers #####################################<br>"
"#############################################<br> <br>Run"
#END

STR	X0
ANDN	C20
STR	C10
ANDN	C15
AND	C20
ORSTR
ONDTMR	T3	D0	C1
OUT	C10

// Rung Run#2
// Offset 10
#BEGIN FMT_COMMENT 
"Jog"
#END

STR	X0
ANDN	C20
STR	C11
ANDN	C15
AND	C20
ORSTR
ONDTMR	T4	D1	C2
OUT	C11

// Rung Run#3
// Offset 20
#BEGIN FMT_COMMENT 
"Thread"
#END

STR	X1
ANDN	C20
STR	C12
ANDN	C15
AND	C20
ORSTR
ONDTMR	T5	D3	C3
OUT	C12

// Rung Run#4
// Offset 30
#BEGIN FMT_COMMENT 
"Stop Buffer"
#END

STRN	X3
NOT
OUT	C15

// Rung Run#5
// Offset 33
#BEGIN FMT_COMMENT 
"Any running signal / Bell"
#END

STR	C10
OR	C11
OR	C12
OUT	C20
ANDPDPF
OUT	Y0

// End of Code Block Run
$PGMEND	Run

// Beginning of Code Block Glue
$PRGRM	Glue

// Rung Glue#1
// Offset 0
STR	X11
ANDN	X12
OUT	Y48

// Rung Glue#2
// Offset 3
STRN	X11
AND	X12
AND	C5
AND	X13
OUT	Y49

// Rung Glue#3
// Offset 8
STR	Y48
OR	Y49
AND	ST2
OUT	Y69

// Rung Glue#4
// Offset 12
STR	X3
ONDTMR	T2	3000	C5
ANDNDPF
OFFDTMR	T0	1400	C0

// Rung Glue#5
// Offset 20
STR	X3
AND	STKC42
OR	Y72
ANDN	T0.Done
AND	ST2
OUT	Y72

// Rung Glue#6
// Offset 26
NOP

// Rung Glue#7
// Offset 27
NOP

// Rung Glue#8
// Offset 28
NOP

// End of Code Block Glue
$PGMEND	Glue

// Beginning of Code Block TestTimer
$PRGRM	TestTimer

// Rung TestTimer#1
// Offset 0
NOP

// Rung TestTimer#2
// Offset 1
STRE	SDT0.DayOfWeek	6
MATH	D4	"0"
NOT
MATH	D4	"SDT0.DayOfWeek + 1"

// Rung TestTimer#3
// Offset 20
STRGE	SDT0.DayOfWeek	D8
ANDLE	SDT0.DayOfWeek	D9
ANDLE	SDT0.Hour	D10
ANDLE	SDT0.Minute	D11
STRGE	D4	D8
ANDLE	D4	D9
ORSTR
OUT	C30

// Rung TestTimer#4
// Offset 46
STR	C30
OR	X11
OR	C31
AND	X10
OUT	C31

// Rung TestTimer#5
// Offset 51
STR	C31
ANDN	C34
ANDGE	SDT0.Hour	UDT0.Hour
ANDGE	SDT0.Minute	UDT0.Minute
OUT	C33
SET	C34
ANDNDPF
RST	C31

// Rung TestTimer#6
// Offset 65
STRE	SDT0.Hour	0
ANDE	SDT0.Minute	0
RST	C31

// Rung TestTimer#7
// Offset 74
NOP

// Rung TestTimer#8
// Offset 75
STR	C36
OR	C33
STR	C35
ANDN	C36
ORSTR
OUT	C35

// Rung TestTimer#9
// Offset 81
NOP

// End of Code Block TestTimer
$PGMEND	TestTimer

#BEGIN ELEMENT_DOC
"X0","","","Air SW on Stacker"
"X1","","","Air Pressure OK"
"X2","","","Stacker Reset PB"
"X3","","","Machine Run Started"
"X4","","","Latch Cam Start Cycle"
"X5","","","Eject In"
"X6","","","Eject Out"
"X7","","","Transfer Operator Side"
"X8","","","Transfer Drive Side"
"X9","","","Operator Side Load In"
"X10","","","Operator Side Load Out"
"X11","","","Tape Glue Manual"
"X12","","","Tape Glue Auto"
"X13","","","Machine In Run"
"X32","","","Guard Door SW"
"Y0","","","Stacker Jam Light"
"Y1","","","Timing Fault Light"
"Y2","","","Gradual Start Valve"
"Y3","","","Operator Side Load Sol"
"Y4","","","Transfer Sol"
"Y5","","","Compression Sol"
"Y8","","","Ejection Sol"
"Y9","","","Vertical Bar Sol"
"Y10","","","Machine Stop Interlock"
"Y48","","","Tape Glue SOL Manual"
"Y49","","","Tape Glue SOL Auto"
"Y69","","","Tape Glue Pump On"
"Y72","","","Tape Power Relay"
"C30","","","Standard Work Week Day"
"C31","","","Arm Auto Warm Glue Lamp"
"C32","","","Auto Warm Glue Armed Lamp"
"C33","","","Auto Heat Glue"
"C34","","","Auto Glue Triggered Today"
"C36","","","Manually Heat Glue"
"C200","","","Enable Stacker Program"
"C201","","","Enable Glue Program"
"C203","","","Enable Stacker Test"
"C400","","","Mock Stacker Operation Pre-Run State"
"C401","","","Mock Stacker Operation Reset State"
"C402","","","Mock Stacker Operation Ejection State"
"C403","","","Mock Stacker Operation Compression State"
"C404","","","Mock Stacker Operation Transfer State"
"C405","","","Mock Stacker Operation Load State"
"C406","","","Mock Stacker Operation Cycle"
"C407","","","Mock Turn On Stacker"
"C408","","","Mock Restart Stacker"
"C600","","","Passed Stacker On Test"
"C601","","","Passed Stacker Pre- Run Error Test"
"C602","","","Passed Stacker Runtime Error Test"
"C603","","","Passed Stacker Detect State Test"
"C604","","","Passed Stacker Set State"
"C605","","","Passed Stacker Set State"
"D30","","","Vertical Bar On Buffer"
"D31","","","Ejection On Buffer"
"D32","","","Compression On Buffer"
"D33","","","Transfer On Buffer"
"D34","","","Load On Buffer"
"D40","","","Vertical Bar Off Buffer"
"D50","","","Stacker Operation Mock State"
"STKC0","","","Eject In Eye Buffer"
"STKC1","","","Eject Out Eye Buffer"
"STKC2","","","Transfer Drive Side Eye Buffer"
"STKC3","","","Transfer Operator Side Eye Buffer"
"STKC4","","","Load In Eye Buffer"
"STKC5","","","Load Out Eye Buffer"
"STKC10","","","Stacker Operation Vertical Bar SOL Buffered"
"STKC11","","","Stacker Operation Ejection SOL Buffered"
"STKC12","","","Stacker Operation Compression SOL Buffered"
"STKC13","","","Stacker Operation Transfer SOL Buffered"
"STKC14","","","Stacker Operation Load SOL Buffered"
"STKC15","","","Stacker Vertical Bar On Buffer"
"STKC16","","","Stacker Vertical Bar Off Buffer"
"STKC17","","","Stacker Ejection Bar On Buffer"
"STKC18","","","Stacker Ejection Bar Off Buffer"
"STKC19","","","Stacker Compression On Buffer"
"STKC20","","","Stacker Compression Off Buffer"
"STKC21","","","Stacker Transfer On Buffer"
"STKC22","","","Stacker Transfer Off Buffer"
"STKC23","","","Stacker Load On Buffer"
"STKC24","","","Stacker Load Off Buffer"
"STKC30","","","Stacker Reset Press"
"STKC31","","","Stacker Cycle Disconnect"
"STKC40","","","Begin Timers"
"STKC41","","","Transition State"
"STKC42","","","Stacker Start Up Cycle Delay"
"STKC43","","","Latch Cycle Open"
"STKC44","SET","",""
"STKC100","","","Stacker Run State"
"STKC120","","","Stacker Pre Run Error State"
"STKC121","","","Stacker Run Time Error State"
"STKC122","","","Stacker Operation Transition State Timeout Error"
"STKC123","","","Stacker Operation Missed Cam Latch Cycle Error"
"STKD15","","","Vertical Bar On Buffer"
"STKD16","","","Vertical Bar Off Buffer"
"STKD17","","","Ejection On Buffer"
"STKD18","","","Ejection Off Buffer"
"STKD19","","","Compression On Buffer"
"STKD20","","","Compression Off Buffer"
"STKD21","","","Transfer On Buffer"
"STKD22","","","Transfer Off Buffer"
"STKD23","","","Load On Buffer"
"STKD24","","","Load Off Buffer"
"STKD40","","","Stacker Transition Lock Out ms"
"STKD41","","","Stacker Transition Time Out ms"
"STKD42","","","Stacker Operation Detected State"
"STKD43","","","Stacker Operation State Set"
"STKD45","","","Stacker Operation Next Cycle State"
#END

